<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WordGym 單字健身坊 — 學生版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* 控制 details 展開/收合符號 */
      details summary span::before {
        content: "＋";
      }
      details[open] summary span::before {
        content: "−";
      }
      
      /* 閃卡翻轉動畫 */
      .flashcard {
        perspective: 1000px;
      }
      .flashcard-inner {
        position: relative;
        width: 100%;
        transition: transform 0.6s;
        transform-style: preserve-3d;
      }
      .flashcard.flipped .flashcard-inner {
        transform: rotateY(180deg);
      }
      .flashcard-front, .flashcard-back {
        position: absolute;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }
      .flashcard-back {
        transform: rotateY(180deg);
      }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gradient-to-b from-indigo-50 to-white min-h-screen">
    <style>
      details summary .icon-plus { display: inline-block; }
      details[open] summary .icon-plus { display: none; }
      details summary .icon-minus { display: none; }
      details[open] summary .icon-minus { display: inline-block; }
      details summary .icon-plus,
      details summary .icon-minus {
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
    <div id="root"></div>
    <script type="text/babel" data-presets="env,react,typescript">
      window.onerror = function(msg, src, line, col, err) {
        const div = document.createElement('div');
        div.style.background = '#b91c1c';
        div.style.color = '#fff';
        div.style.padding = '12px';
        div.style.fontFamily = 'monospace';
        div.textContent = `Error: ${msg} (line ${line}, column ${col})`;
        document.body.prepend(div);
      };

      const { useEffect, useMemo, useRef, useState } = React;

      const useHashRoute = () => {
        const [hash, setHash] = useState(() => window.location.hash || "#/");
        useEffect(() => {
          const onHash = () => {
            setHash(window.location.hash || "#/");
            // 當路由改變時，自動滾動到頁面頂部
            window.scrollTo(0, 0);
          };
          window.addEventListener("hashchange", onHash);
          return () => window.removeEventListener("hashchange", onHash);
        }, []);
        const push = (h) => { 
          if (h !== window.location.hash) {
            window.location.hash = h;
            // 當程式化改變路由時，也滾動到頂部
            window.scrollTo(0, 0);
          }
        };
        return { hash, push };
      };

      const POS_LABEL = {
        noun: "名詞", verb: "動詞", adjective: "形容詞", adverb: "副詞",
        pronoun: "代名詞", preposition: "介系詞", conjunction: "連接詞", other: "其他"
      };
      const ALL_POS = Object.keys(POS_LABEL);
      
      // 主題標籤
      const THEME_LABEL = {
        highschool_climate: "高中氣候"
      };
      const ALL_THEMES = Object.keys(THEME_LABEL);
      
      const LS = { favorites: "mvp_vocab_favorites", dataset: "mvp_vocab_dataset_v36", presetApplied: "mvp_vocab_preset_applied_v36", homeFilters: "mvp_home_filters_v1", userExamples: "mvp_vocab_user_examples_v1", quizHistory: "mvp_vocab_quiz_history_v1", wrongWordsQuiz: "mvp_vocab_wrong_words_quiz_v1", userName: "mvp_vocab_user_name_v1" };
      const PRESET_VERSION = 'csv_v9_empty';
      const HIGH_SCHOOL_CLIMATE_CSV_EMBEDDED = "";

      // Google Sheet 配置
      const GOOGLE_SHEET_CONFIG = {
        enabled: true,
        showImporter: false,
        sheets: [
          {
            name: '高中氣候單字',
            sheetId: '1cGcjubwXM6BA7ynUW7sqLveTzD_vgdM_ETKS4sjqfIE',
            gid: '409060486',
            theme: 'highschool_climate'
          }
        ]
      };

      const CSV_SOURCES = [];

const speak = (rawText) => {
        const text = String(rawText || '').trim();
        if (!text || !('speechSynthesis' in window)) return;
        try {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = 'en-US';
          window.speechSynthesis.speak(utterance);
        } catch {}
      };

      const loadFromGoogleSheet = async (sheetConfig) => {
        try {
          const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetConfig.sheetId}/export?format=csv&gid=${sheetConfig.gid}`;
          const response = await fetch(csvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const csvText = await response.text();
          const rows = parseCSV(csvText);
          return { rows, theme: sheetConfig.theme };
        } catch (error) {
          console.error(`載入失敗: ${sheetConfig.name}`, error);
          throw error;
        }
      };

      const loadAllGoogleSheets = async () => {
        if (!GOOGLE_SHEET_CONFIG.enabled) return [];
        const results = [];
        for (const sheetConfig of GOOGLE_SHEET_CONFIG.sheets) {
          try {
            const result = await loadFromGoogleSheet(sheetConfig);
            results.push(result);
          } catch (error) {
            console.warn(`跳過: ${sheetConfig.name}`);
          }
        }
        return results;
      };

      const Button = ({ children, onClick, variant = "primary", type = "button", className = "", disabled = false }) => {
        const base = "px-4 py-2 rounded-xl font-medium transition focus:outline-none focus:ring-2 focus:ring-offset-2";
        const variants = {
          primary: "bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500",
          ghost: "bg-white/80 text-gray-700 border border-gray-200 hover:bg-white focus:ring-gray-300",
          danger: "bg-rose-600 text-white hover:bg-rose-700 focus:ring-rose-500",
          success: "bg-green-600 text-white hover:bg-green-700 focus:ring-green-500"
        };
        const variantClass = variants[variant] || variants.primary;
        const disabledClass = disabled ? "opacity-60 cursor-not-allowed hover:bg-inherit" : "";
        return (
          <button
            type={type}
            onClick={disabled ? undefined : onClick}
            disabled={disabled}
            className={`${base} ${variantClass} ${disabledClass} ${className}`}
          >
            {children}
          </button>
        );
      };

      const SpeakerButton = ({ onClick, label, className = "" }) => (
        <button
          type="button"
          onClick={onClick}
          aria-label={label}
          title={label}
          className={`inline-flex h-8 w-8 items-center justify-center rounded-full border border-indigo-200 bg-white text-indigo-600 shadow-sm transition hover:bg-indigo-50 hover:text-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 ${className}`}
        >
          <svg viewBox="0 0 24 24" fill="currentColor" className="h-4 w-4">
            <path d="M4 9.25v5.5c0 .69.56 1.25 1.25 1.25H7l3.29 2.63c.83.66 2.04.07 2.04-1V6.62c0-1.07-1.21-1.66-2.04-1L7 8.25H5.25C4.56 8.25 4 8.81 4 9.25Zm11.21-2.46a.75.75 0 0 0-.97 1.14 4.5 4.5 0 0 1 0 7.14.75.75 0 0 0 .97 1.14 6 6 0 0 0 0-9.42Zm2.79-1.95a.75.75 0 0 0-.97 1.13 7.5 7.5 0 0 1 0 11.56.75.75 0 0 0 .97 1.13 9 9 0 0 0 0-13.82Z" />
          </svg>
        </button>
      );

            window.__INITIAL_DATASET__ = [];

      const exampleFor = (word, pos) => {
        const w = String(word || '').trim();
        if (!w) return '';
        const lower = w.toLowerCase();
        const article = /^[aeiou]/i.test(w) ? 'an' : 'a';
        if (pos === 'adjective' && lower === 'alike') return 'They look alike.';
        if (pos === 'verb') return `They ${lower} every day.`;
        if (pos === 'adjective') return `It is ${lower}.`;
        if (pos === 'adverb') return `He speaks ${lower}.`;
        if (pos === 'preposition') return `We talked ${lower} the plan.`;
        if (pos === 'conjunction') return `I left ${lower} the rain started.`;
        if (pos === 'pronoun') return `${w} is here.`;
        return `This is ${article} ${lower}.`;
      };

      const translationFor = (word, pos) => {
        const w = String(word || '').trim();
        if (!w) return '';
        const lower = w.toLowerCase();
        const DICT_ZH = {
          activity: "活動", action: "行動", actor: "男演員", actress: "女演員", add: "加",
          about: "關於", above: "在上方", across: "穿越", against: "反對", along: "沿著", among: "在…之中", around: "在周圍", as: "作為/因為", after: "之後",
          afraid: "害怕的", angry: "生氣的", able: "能夠的", active: "活躍的", alive: "活著的", alike: "相似",
          animal: "動物", airport: "機場", apple: "蘋果", agree: "同意", arrive: "到達", ask: "詢問",
          available: "可用的", away: "離開的", we: "我們", you: "你/你們", they: "他們"
        };
        const PREP_ZH = {
          about: "關於", above: "在…上方", across: "穿越/橫越", against: "反對/靠著",
          along: "沿著", among: "在…之中", around: "在…周圍/大約", as: "作為/因為", after: "在…之後"
        };
        if (pos === 'verb') {
          const zh = DICT_ZH[lower] || w;
          return `他們每天${zh}。`;
        }
        if (pos === 'adjective') {
          if (lower === 'alike') return '他們看起來很相似。';
          const zh = DICT_ZH[lower] || `${w}的`;
          return `它很${zh.replace(/的$/, '的')}。`;
        }
        if (pos === 'adverb') {
          const zh = DICT_ZH[lower] || w;
          return `他說話${zh}地。`;
        }
        if (pos === 'pronoun') {
          const zh = DICT_ZH[lower] || w;
          return `${zh}在這裡。`;
        }
        if (pos === 'preposition') {
          const zh = PREP_ZH[lower] || DICT_ZH[lower] || w;
          return `我們談論${zh}這個計畫。`;
        }
        if (pos === 'conjunction') {
          return `我在${DICT_ZH[lower] || w}雨開始時離開。`;
        }
        const zh = DICT_ZH[lower] || w;
        const isZh = /[\u4e00-\u9fff]/.test(zh);
        return `這是${isZh ? '' : '一個'}${zh}。`;
      };
      
      const posLabelFromArray = (tags = []) => {
        return (Array.isArray(tags) ? tags : [])
          .map((tag) => POS_LABEL[tag] || tag)
          .filter(Boolean)
          .join('、');
      };

      const wordToMarkdown = (word, selPos, extras = {}) => {
        if (!word) return '';
        const sections = extras.sections || { pos: true, relations: true, affix: true };
        const lines = [];
        const heading = (extras.title ?? word.english_word ?? '').trim();
        if (heading) {
          lines.push(`## ${heading}`);
        }

        const basicLines = [];
        const kk = (extras.kk_phonetic ?? word.kk_phonetic ?? '').trim();
        if (kk) basicLines.push(`- KK音標：${kk}`);
        const posText = posLabelFromArray(word.posTags || []);
        if (posText) basicLines.push(`- 詞性：${posText}`);
        const levelText = String(extras.level ?? word.level ?? '').trim();
        if (levelText) basicLines.push(`- Level：${levelText}`);
        const themeLabels = getThemeDisplayLabels(word);
        if (themeLabels.length) basicLines.push(`- 主題：${themeLabels.join('、')}`);
        if (basicLines.length) {
          if (lines.length) lines.push('');
          lines.push('### 基本資訊', ...basicLines);
        }

        const exampleLines = [];
        const exampleSentence = (extras.example_sentence ?? word.example_sentence ?? '').trim();
        const exampleTranslation = (extras.example_translation ?? word.example_translation ?? '').trim();
        const exampleSentence2 = (extras.example_sentence_2 ?? word.example_sentence_2 ?? '').trim();
        const exampleTranslation2 = (extras.example_translation_2 ?? word.example_translation_2 ?? '').trim();
        if (exampleSentence) exampleLines.push(`- 例句1：${exampleSentence}`);
        if (exampleTranslation) exampleLines.push(`  → ${exampleTranslation}`);
        if (exampleSentence2) exampleLines.push(`- 例句2：${exampleSentence2}`);
        if (exampleTranslation2) exampleLines.push(`  → ${exampleTranslation2}`);
        if (exampleLines.length) {
          lines.push('', '### 例句', ...exampleLines);
        }

        if (sections.pos) {
          const grammarLines = [];
          const primaryPos = selPos || word.grammar_main_category || (word.posTags || [])[0];
          if (primaryPos) grammarLines.push(`- 主要詞性：${POS_LABEL[primaryPos] || primaryPos}`);
          const subCat = (extras.grammar_sub_category ?? word.grammar_sub_category ?? '').trim();
          if (subCat) grammarLines.push(`- 子分類：${subCat}`);
          const gFunc = (extras.grammar_function ?? word.grammar_function ?? '').trim();
          if (gFunc) grammarLines.push(`- 語法功能：${gFunc}`);
          const gPattern = (extras.applicable_sentence_pattern ?? word.applicable_sentence_pattern ?? '').trim();
          if (gPattern) grammarLines.push(`- 常見句型：${gPattern}`);
          const formsSource = extras.word_forms ?? word.word_forms ?? [];
          const formsList = Array.isArray(formsSource) ? formsSource : multiSplit(formsSource || '');
          const cleanedForms = formsList.filter(Boolean);
          if (cleanedForms.length) grammarLines.push(`- 詞性變化：${cleanedForms.join('、')}`);
          if (grammarLines.length) {
            lines.push('', '### 詞性', ...grammarLines);
          }
        }

        if (sections.relations) {
          const relationLines = [];
          const synonyms = extras.synonyms ?? word.synonyms ?? [];
          const synList = Array.isArray(synonyms) ? synonyms : multiSplit(synonyms || '');
          if (synList.length) relationLines.push(`- 同義字：${synList.join('、')}`);
          const antonyms = extras.antonyms ?? word.antonyms ?? [];
          const antList = Array.isArray(antonyms) ? antonyms : multiSplit(antonyms || '');
          if (antList.length) relationLines.push(`- 反義字：${antList.join('、')}`);
          const confusables = extras.confusables ?? word.confusables ?? [];
          const confList = Array.isArray(confusables) ? confusables : multiSplit(confusables || '');
          if (confList.length) relationLines.push(`- 易混淆字：${confList.join('、')}`);
          if (relationLines.length) {
            lines.push('', '### 同義／反義／易混淆', ...relationLines);
          }
        }

        if (sections.affix) {
          const affix = extras.affix_info ?? word.affix_info ?? {};
          const affixLines = [];
          const prefix = String(affix.prefix || '').trim();
          const root = String(affix.root || '').trim();
          const suffix = String(affix.suffix || '').trim();
          const meaning = String(affix.meaning || '').trim();
          const example = String(affix.example || '').trim();
          if (prefix) affixLines.push(`- 字首：${prefix}`);
          if (root) affixLines.push(`- 字根：${root}`);
          if (suffix) affixLines.push(`- 字尾：${suffix}`);
          if (meaning) affixLines.push(`- 字源意涵：${meaning}`);
          if (example) affixLines.push(`- 延伸例子：${example}`);
          if (affixLines.length) {
            lines.push('', '### 字根字首字尾', ...affixLines);
          }
        }

        return lines.join('\n');
      };

      const makeBaseDataset = () => [];

      const normalizePOS = (raw) => {
        const s=String(raw||"").toLowerCase();
        if (s.includes("代名") || s.includes("pronoun")) return "pronoun";
        if (s.includes("副詞") || s.includes("adv")) return "adverb";
        if (s.includes("形容") || s.includes("adj")) return "adjective";
        if (s.includes("動詞") || s.includes("verb") || s==="v") return "verb";
        if (s.includes("名詞") || s.includes("noun") || s==="n") return "noun";
        if (s.includes("介系") || s.includes("preposition") || s.includes("prep")) return "preposition";
        if (s.includes("連接") || s.includes("conjunction") || s.includes("conj")) return "conjunction";
        return "other";
      };

      const multiSplit = (text) => {
        const out = []; let token = ""; const str = String(text);
        const isDelim = (ch) => /[,;，、\n\r]/.test(ch);
        for (let i=0; i<str.length; i++) {
          const ch = str[i];
          if (isDelim(ch)) { if (token) out.push(token); token = ""; } else { token += ch; }
        }
        if (token) out.push(token);
        return out.map(s=>s.trim()).filter(Boolean);
      };

      const emptyWordFormsDetail = () => ({ base: [], idiom: [], compound: [], derivation: [] });

      const dedupeList = (arr=[]) => Array.from(new Set(arr.map(s=>s.trim()).filter(Boolean)));

      const mergeThemes = (...values) => {
        const result = new Set();
        const ingest = (val, allowSplit = true) => {
          if (val === undefined || val === null) return;
          if (Array.isArray(val)) { val.forEach((item) => ingest(item, true)); return; }
          const str = String(val).trim();
          if (!str) return;
          if (allowSplit) {
            const tokens = multiSplit(str);
            if (tokens.length > 1) {
              tokens.forEach((token) => ingest(token, false));
              return;
            }
          }
          result.add(str);
        };
        values.forEach((val) => ingest(val, true));
        return Array.from(result);
      };

      const getWordThemes = (word) => mergeThemes(word?.themes, word?.theme);
      const wordHasTheme = (word, themeKey) => {
        if (!themeKey) return false;
        return getWordThemes(word).includes(themeKey);
      };
      
      // 將主題鍵對應到顯示標籤，避免重複顯示
      const getThemeDisplayLabels = (word) => {
        const themes = getWordThemes(word);
        const labels = new Set();
        
        themes.forEach(theme => {
          if (theme === '氣候' || theme === 'climate') {
            labels.add('高中氣候');
          } else {
            labels.add(THEME_LABEL[theme] || theme);
          }
        });
        
        return Array.from(labels);
      };

      const categorizeWordForms = (source=[], baseWord='') => {
        const detail = emptyWordFormsDetail();
        const baseLower = String(baseWord||'').toLowerCase();
        source.forEach(item => {
          const text = String(item || '').trim();
          if (!text) return;
          const lower = text.toLowerCase();
          if (text.includes('*') || (baseLower && lower === baseLower)) {
            detail.base.push(text);
          }
          else if (/[\s]/.test(text) && !text.includes('-')) {
            detail.idiom.push(text);
          }
          else if (text.includes('-')) {
            detail.compound.push(text);
          }
          else if (baseLower && (lower.startsWith(baseLower) || baseLower.startsWith(lower))) {
            detail.derivation.push(text);
          }
          else {
            detail.derivation.push(text);
          }
        });
        detail.base = dedupeList(detail.base);
        detail.idiom = dedupeList(detail.idiom);
        detail.compound = dedupeList(detail.compound);
        detail.derivation = dedupeList(detail.derivation);
        return detail;
      };

      const normalizeWordFormsDetail = (rawDetail, fallback=[], baseWord='') => {
        let detail = emptyWordFormsDetail();
        if (rawDetail && typeof rawDetail === 'object' && !Array.isArray(rawDetail)) {
          detail.base = dedupeList(rawDetail.base || rawDetail.root || []);
          detail.idiom = dedupeList(rawDetail.idiom || rawDetail.phrase || []);
          detail.compound = dedupeList(rawDetail.compound || rawDetail.compounds || []);
          detail.derivation = dedupeList(rawDetail.derivation || rawDetail.other || rawDetail.misc || []);
        }
        const remaining = [];
        if (Array.isArray(rawDetail)) remaining.push(...rawDetail);
        if (Array.isArray(fallback)) remaining.push(...fallback);
        if (typeof fallback === 'string') remaining.push(...multiSplit(fallback));
        const categorized = categorizeWordForms(remaining, baseWord);
        if (!detail.base.length) detail.base = categorized.base;
        if (!detail.idiom.length) detail.idiom = categorized.idiom;
        if (!detail.compound.length) detail.compound = categorized.compound;
        if (!detail.derivation.length) detail.derivation = categorized.derivation;
        return detail;
      };

      const ensureWordFormsDetail = (word) => {
        const detail = normalizeWordFormsDetail(word.word_forms_detail, word.word_forms, word.english_word);
        const combined = dedupeList([...detail.base, ...detail.idiom, ...detail.compound, ...detail.derivation]);
        const themeList = mergeThemes(word.themes, word.theme);
        const primaryTheme = themeList.length ? themeList[0] : (String(word.theme || '').trim() || '');
        return {
          ...word,
          word_forms_detail: detail,
          // 保留原始的 word_forms 字串，不要覆蓋
          // word_forms: combined,
          theme: primaryTheme,
          themes: themeList
        };
      };

      const INITIAL_DATASET_RAW = (window.__INITIAL_DATASET__ || []);
      const INITIAL_DATASET = INITIAL_DATASET_RAW.map(ensureWordFormsDetail);


      const mergeWordFormsDetail = (target, source) => {
        const base = target ? {
          base: dedupeList(target.base || []),
          idiom: dedupeList(target.idiom || []),
          compound: dedupeList(target.compound || []),
          derivation: dedupeList(target.derivation || [])
        } : emptyWordFormsDetail();
        if (!source) return base;
        base.base = dedupeList([...base.base, ... (source.base || [])]);
        base.idiom = dedupeList([...base.idiom, ... (source.idiom || [])]);
        base.compound = dedupeList([...base.compound, ... (source.compound || [])]);
        base.derivation = dedupeList([...base.derivation, ... (source.derivation || source.other || [])]);
        return base;
      };

      function parseCSV(text) {
        const rows = [];
        let i=0, cur='', inQ=false, row=[];
        const pushCell=()=>{ row.push(cur); cur=''; };
        const pushRow=()=>{ rows.push(row); row=[]; };
        while(i<text.length){
          const ch=text[i];
          if(ch==='"') { if(inQ && text[i+1]==='"'){ cur+='"'; i+=2; continue; } inQ=!inQ; i++; continue; }
          if(!inQ && ch===','){ pushCell(); i++; continue; }
          if(!inQ && ch==='\n'){ pushCell(); pushRow(); i++; continue; }
          if(!inQ && ch==='\r' && text[i+1]==='\n'){ pushCell(); pushRow(); i+=2; continue; }
          cur+=ch; i++;
        }
        if(cur.length||row.length){ pushCell(); pushRow(); }
        if(!rows.length) return [];
        const headers=(rows[0]||[]).map(h=>String(h||'').replace(/^\uFEFF/, '').trim());
      
        return rows.slice(1).map(cols=>{ const obj={}; for(let k=0;k<headers.length;k++){ const key=headers[k]; if(!key) continue; obj[key]=(cols[k]||'').trim(); } return obj; });
      }

      const ADV_FREQUENCY = new Set(['always','usually','often','sometimes','seldom','rarely','never','again']);
      const ADV_DEGREE    = new Set(['very','quite','too','enough','almost','altogether']);
      const ADV_PLACE     = new Set(['here','there','above','below','abroad','anywhere','away','around','along','ahead']);
      const ADV_TIME      = new Set(['already','now','today','yesterday','tonight','soon']);
      const ADV_MANNER    = new Set(['aloud','alone']);

      const grammarDefaults = (word, pos, subcat='') => {
        const w = String(word);
        const lw = w.toLowerCase();
        const s = String(subcat||'');
        let func = '', patt = '';
        if (pos === 'pronoun') {
          if (s.includes('主格')) { func = '作主詞（Subject）'; patt = `${w} + V ...`; }
          else if (s.includes('受格')) { func = '作受詞（Object）'; patt = `S + V + ${w}`; }
          else if (s.includes('所有格形容')) { func = '修飾名詞（所有格形容詞）'; patt = `${w} + N`; }
          else if (s.includes('所有格')) { func = '代替名詞片語（所有格代名詞）'; patt = `S + be + ${w}`; }
          else if (s.includes('反身')) { func = '反身受詞／強調'; patt = `S + V + ${w}`; }
          else { func = '代替名詞（泛指）'; patt = `${w} + V ... / S + V + ${w}`; }
        }
        else if (pos === 'adverb') {
          if (ADV_FREQUENCY.has(lw)) { func = '頻率副詞：修飾動詞（be/助動詞之後、一般動詞之前）'; patt = 'S + (助動詞) + [頻率副詞] + V ... / be + [頻率副詞]'; }
          else if (ADV_DEGREE.has(lw)) { func = '程度副詞：修飾形容詞/副詞'; patt = '[程度副詞] + Adj/Adv'; }
          else if (ADV_PLACE.has(lw)) { func = '地點/方向副詞：常置句末或動詞後'; patt = 'S + V + (O) + [地點副詞]'; }
          else if (ADV_TIME.has(lw)) { func = '時間副詞：句末或句首'; patt = '[時間副詞], S + V ... / S + V + [時間副詞]'; }
          else if (ADV_MANNER.has(lw)) { func = '方式副詞：說明動作方式'; patt = 'S + V + [方式副詞]'; }
          else if (lw === 'also') { func = '添加副詞：也、還'; patt = 'S + also + V / be + also'; }
          else { func = '副詞：修飾動詞、形容詞或整句'; patt = 'S + V + (O) + Adv / Adv + 句子'; }
        }
        return { grammar_function: func, sentence_pattern: patt };
      };

      const useDataset = () => {
        const themeOrderRef = useRef({});

        const applyThemeOrder = (word, themes, counters = themeOrderRef.current) => {
          if (!word) return word;
          const list = Array.isArray(themes) ? themes : getWordThemes(word);
          if (!word.theme_order) word.theme_order = {};
          list.forEach((theme) => {
            const key = String(theme || '').trim();
            if (!key) return;
            if (word.theme_order[key] === undefined) {
              const idx = counters[key] ?? 0;
              word.theme_order[key] = idx;
              counters[key] = idx + 1;
            }
          });
          return word;
        };

        const hydrateDataset = (items, resetCounters = true) => {
          const counters = resetCounters ? {} : { ...themeOrderRef.current };
          const hydrated = (Array.isArray(items) ? items : []).map((item) => {
            const prepared = ensureWordFormsDetail(item);
            const clone = { ...prepared };
            if (clone.theme_order && typeof clone.theme_order === 'object') {
              Object.entries(clone.theme_order).forEach(([theme, order]) => {
                const num = Number(order);
                if (Number.isFinite(num) && num >= 0) {
                  counters[theme] = Math.max(counters[theme] || 0, num + 1);
                }
              });
            }
            applyThemeOrder(clone, getWordThemes(clone), counters);
            return clone;
          });
          themeOrderRef.current = counters;
          return hydrated;
        };

        const [data, setData] = useState(() => {
          try {
            const storedVersion = localStorage.getItem(LS.presetApplied);
            if (storedVersion === PRESET_VERSION) {
              const raw = localStorage.getItem(LS.dataset);
              if (raw) {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed) && parsed.length) {
                  const hydrated = hydrateDataset(parsed);
                  // 測試：為 conservation 自動加入影片連結
                  const conservation = hydrated.find(w => w.english_word === 'conservation');
                  if (conservation && !conservation.videoUrl) {
                    conservation.videoUrl = 'https://www.youtube.com/watch?v=C8iYen-4V2A';
                  }
                  return hydrated;
                }
              }
            }
          } catch {}
          try {
            localStorage.removeItem(LS.dataset);
            localStorage.removeItem(LS.presetApplied);
          } catch {}
          const baseData = hydrateDataset(makeBaseDataset());
          // 測試：為 conservation 自動加入影片連結
          const conservation = baseData.find(w => w.english_word === 'conservation');
          if (conservation && !conservation.videoUrl) {
            conservation.videoUrl = 'https://www.youtube.com/watch?v=C8iYen-4V2A';
          }
          return baseData;
        });

        useEffect(() => {
          try { localStorage.setItem(LS.dataset, JSON.stringify(data)); } catch {}
        }, [data]);

        const addItems = (items, opts = {}) => {
          const overrideExamples = !!opts.overrideExamples;
          const replace = !!opts.replace;
          const stats = { added: 0, merged: 0, replaced: 0, tagsAdded: {}, totalBefore: 0, totalAfter: 0 };
          const incomingList = Array.isArray(items) ? items : [];

          setData((current) => {
            stats.totalBefore = current.length;
            const baseCounters = {};
            const preparedCurrent = current.map((item) => {
              const prepared = ensureWordFormsDetail(item);
              const clone = { ...prepared };
              applyThemeOrder(clone, getWordThemes(clone), baseCounters);
              return clone;
            });

            const counters = replace ? {} : baseCounters;
            if (replace) {
              stats.replaced = current.length;
            }
            themeOrderRef.current = counters;

            const next = replace ? [] : preparedCurrent;
            const byWord = new Map(next.map((w) => [String(w.english_word || '').toLowerCase(), w]));
            let maxId = next.reduce((m, w) => Math.max(m, Number(w.id) || 0), 0);

            const mergeAffixInfo = (target, source) => {
              if (!source) return;
              if (!target.affix_info) {
                target.affix_info = { prefix: '', root: '', suffix: '', meaning: '', example: '' };
              }
              ['prefix', 'root', 'suffix', 'meaning', 'example'].forEach((key) => {
                if (!target.affix_info[key] && source[key]) {
                  target.affix_info[key] = source[key];
                }
              });
            };

            const ensureTag = (wordObj, tag) => {
              if (!tag) return;
              if (!wordObj.posTags) wordObj.posTags = [];
              if (!wordObj.posTags.includes(tag)) {
                wordObj.posTags = [...wordObj.posTags, tag];
                wordObj.basic_pos = wordObj.posTags.join(', ');
                stats.tagsAdded[tag] = (stats.tagsAdded[tag] || 0) + 1;
              }
            };

            incomingList.forEach((raw) => {
              if (!raw) return;
              const english = String(raw.english_word || raw.word || raw.Word || raw['英文'] || raw['英文單字'] || '').trim();
              if (!english) return;

              const posSources = [raw.posTags, raw.basic_pos, raw.grammar_main_category, raw['詞性'], raw['詞性分類'], raw.pos];
              const tagTokens = [];
              posSources.forEach((src) => {
                if (!src) return;
                if (Array.isArray(src)) tagTokens.push(...src);
                else tagTokens.push(...multiSplit(src));
              });
              const tags = Array.from(new Set(tagTokens.map(normalizePOS).filter(Boolean)));
              if (!tags.length) tags.push('other');

              const formsRaw = raw.word_forms ?? raw['詞性變化'];
              // 保留原始字串用於顯示，同時為 normalizeWordFormsDetail 準備陣列
              const formsForDetail = Array.isArray(formsRaw) ? formsRaw : multiSplit(formsRaw || '');
              const levelValue = raw.level ?? raw.Level ?? raw.LEVEL ?? raw['Level'] ?? raw['LEVEL'] ?? '';
              const level = String(levelValue || '').trim();
              const normalizedDetail = normalizeWordFormsDetail(raw.word_forms_detail, formsForDetail, english);
              let themes = mergeThemes(raw.themes, raw.theme, raw['主題'], raw.default_theme, raw.defaultTheme);
              if (!themes.length && tags.length) themes = mergeThemes(tags[0]);
              if (!themes.length) themes = ['general'];

              const toList = (value, alt) => Array.isArray(value) ? value : multiSplit(value || alt || '');
              const derivatives = toList(raw.derivatives, raw['衍生詞']);
              const synonyms = toList(raw.synonyms, raw['同義字']);
              const antonyms = toList(raw.antonyms, raw['反義字']);
              const confusables = toList(raw.confusables, raw['易混淆字']);

              const affixSource = (raw.affix_info && typeof raw.affix_info === 'object') ? raw.affix_info : {};
              const incoming = ensureWordFormsDetail({
                id: null,
                english_word: english,
                kk_phonetic: raw.kk_phonetic || raw.KK || raw['KK音標'] || '',
                chinese_definition: raw.chinese_definition || raw['中譯'] || raw['中文'] || '',
                posTags: tags,
                basic_pos: tags.join(', '),
                grammar_main_category: normalizePOS(tags[0] || raw.grammar_main_category || raw['詞性'] || ''),
                grammar_sub_category: raw.grammar_sub_category || raw['詞性分類'] || '',
                grammar_function: raw.grammar_function || raw['語法功能'] || '',
                applicable_sentence_pattern: raw.applicable_sentence_pattern || raw['句型'] || '',
                example_sentence: raw.example_sentence || raw['例句'] || raw['ai例句'] || '',
                example_translation: raw.example_translation || raw['翻譯'] || raw['ai例句中譯'] || '',
                example_sentence_2: raw.example_sentence_2 || raw['例句2'] || raw['例句_2'] || raw.sentence2 || raw['GSAT_Example_Sentence_1'] || '',
                example_translation_2: raw.example_translation_2 || raw['翻譯2'] || raw['翻譯_2'] || raw.translation2 || raw['GSAT_Translation_1'] || '',
                example_sentence_3: raw.example_sentence_3 || raw['例句3'] || raw['例句_3'] || raw.sentence3 || '',
                example_translation_3: raw.example_translation_3 || raw['翻譯3'] || raw['翻譯_3'] || raw.translation3 || '',
                example_sentence_4: raw.example_sentence_4 || raw['例句4'] || raw['例句_4'] || raw.sentence4 || '',
                example_translation_4: raw.example_translation_4 || raw['翻譯4'] || raw['翻譯_4'] || raw.translation4 || '',
                example_sentence_5: raw.example_sentence_5 || raw['例句5'] || raw['例句_5'] || raw.sentence5 || '',
                example_translation_5: raw.example_translation_5 || raw['翻譯5'] || raw['翻譯_5'] || raw.translation5 || '',
                example_source_2: (() => {
                  // 優先使用已處理的 example_source_2
                  if (raw.example_source_2) return raw.example_source_2;
                  // 否則從 Year_1, Part_1, Source_1 組合
                  const year = raw['Year_1'] || '';
                  const part = raw['Part_1'] || '';
                  const source = raw['Source_1'] || '';
                  if (year && part && source) {
                    return `${year}\t${part}\t${source}`;
                  }
                  return '';
                })(),
                theme: themes[0] || '',
                themes,
                level,
                cefr: raw.cefr || raw.CEFR || raw['CEFR'] || '',
                word_forms: formsRaw || '', // 使用原始字串，保留換行
                word_forms_detail: normalizedDetail,
                derivatives,
                synonyms,
                antonyms,
                confusables,
                phrases: Array.isArray(raw.phrases) ? raw.phrases : (typeof raw.phrases === 'string' ? raw.phrases.split(';').map(p => p.trim()).filter(p => p) : (raw['片語'] || '').split(';').map(p => p.trim()).filter(p => p)),
                videoUrl: raw.videoUrl || raw.video_url || raw['影片連結'] || raw['影片'] || '',
                affix_info: {
                  prefix: affixSource.prefix || raw.affix_prefix || raw.prefix || raw['字首'] || '',
                  root: affixSource.root || raw.affix_root || raw.root || raw['字根'] || '',
                  suffix: affixSource.suffix || raw.affix_suffix || raw.suffix || raw['字尾'] || '',
                  meaning: affixSource.meaning || raw.affix_meaning || raw.meaning || raw['意思'] || '',
                  example: affixSource.example || raw.affix_example || raw.example || raw['例子'] || ''
                }
              });

              const key = english.toLowerCase();
              const existing = byWord.get(key);
              if (existing) {
                incoming.posTags.forEach((tag) => ensureTag(existing, tag));
                const combinedThemes = mergeThemes(existing.themes, existing.theme, themes);
                existing.themes = combinedThemes;
                if (!existing.theme && combinedThemes.length) existing.theme = combinedThemes[0];
                if (level) existing.level = level;
                applyThemeOrder(existing, combinedThemes, counters);

                if (!existing.kk_phonetic && incoming.kk_phonetic) existing.kk_phonetic = incoming.kk_phonetic;
                if (!existing.chinese_definition && incoming.chinese_definition) existing.chinese_definition = incoming.chinese_definition;
                if (!existing.grammar_main_category && incoming.grammar_main_category) existing.grammar_main_category = incoming.grammar_main_category;
                if (!existing.grammar_sub_category && incoming.grammar_sub_category) existing.grammar_sub_category = incoming.grammar_sub_category;
                if (!existing.grammar_function && incoming.grammar_function) existing.grammar_function = incoming.grammar_function;
                if (!existing.applicable_sentence_pattern && incoming.applicable_sentence_pattern) existing.applicable_sentence_pattern = incoming.applicable_sentence_pattern;
                if (!existing.theme && incoming.theme) existing.theme = incoming.theme;

                const primaryPos = existing.posTags?.[0] || incoming.posTags[0] || 'noun';
                const autoSentence = exampleFor(existing.english_word, primaryPos);
                const autoTranslation = translationFor(existing.english_word, primaryPos);

                if (incoming.example_sentence && (overrideExamples || !existing.example_sentence || existing.example_sentence === autoSentence)) {
                  existing.example_sentence = incoming.example_sentence;
                }
                if (incoming.example_translation && (overrideExamples || !existing.example_translation || existing.example_translation === autoTranslation)) {
                  existing.example_translation = incoming.example_translation;
                }
                if (incoming.example_sentence_2 && (overrideExamples || !existing.example_sentence_2)) {
                  existing.example_sentence_2 = incoming.example_sentence_2;
                }
                if (incoming.example_translation_2 && (overrideExamples || !existing.example_translation_2)) {
                  existing.example_translation_2 = incoming.example_translation_2;
                }

                existing.word_forms_detail = mergeWordFormsDetail(existing.word_forms_detail, incoming.word_forms_detail);
                // word_forms 是字串，不需要合併，只更新
                if (incoming.word_forms && !existing.word_forms) {
                  existing.word_forms = incoming.word_forms;
                }
                existing.derivatives = dedupeList([...(existing.derivatives || []), ...incoming.derivatives]);
                existing.synonyms = dedupeList([...(existing.synonyms || []), ...incoming.synonyms]);
                existing.antonyms = dedupeList([...(existing.antonyms || []), ...incoming.antonyms]);
                existing.confusables = dedupeList([...(existing.confusables || []), ...incoming.confusables]);
                // phrases 是陣列
                existing.phrases = dedupeList([...(existing.phrases || []), ...(incoming.phrases || [])]);
                mergeAffixInfo(existing, incoming.affix_info);
                
                // 更新影片連結（如果有新的）
                if (incoming.videoUrl && !existing.videoUrl) {
                  existing.videoUrl = incoming.videoUrl;
                }

                Object.assign(existing, ensureWordFormsDetail(existing));
                stats.merged += 1;
              } else {
                maxId += 1;
                const firstPos = incoming.posTags[0] || 'other';
                const primaryTheme = incoming.theme || themes[0] || 'general';
                const newWord = ensureWordFormsDetail({
                  ...incoming,
                  id: maxId,
                  theme: primaryTheme,
                  themes,
                  grammar_main_category: incoming.grammar_main_category || firstPos,
                  example_sentence: incoming.example_sentence || exampleFor(english, firstPos),
                  example_translation: incoming.example_translation || translationFor(english, firstPos)
                });
                newWord.posTags = incoming.posTags;
                newWord.basic_pos = incoming.posTags.join(', ');
                if (!newWord.theme) newWord.theme = primaryTheme;
                newWord.themes = mergeThemes(newWord.themes, newWord.theme);
                applyThemeOrder(newWord, newWord.themes, counters);
                if (incoming.affix_info) newWord.affix_info = incoming.affix_info;
                next.push(newWord);
                byWord.set(key, newWord);
                stats.added += 1;
              }
            });

            themeOrderRef.current = counters;
            stats.totalAfter = next.length;
            return next;
          });

          return stats;
        };

        const reset = () => {
          try {
            localStorage.removeItem(LS.dataset);
            localStorage.removeItem(LS.presetApplied);
          } catch {}
          setData(hydrateDataset(makeBaseDataset()));
        };

        useEffect(() => {
          let cancelled = false;
          const ensureCsvPreset = async () => {
            try { if (localStorage.getItem(LS.presetApplied) === PRESET_VERSION) return; } catch {}
            const aggregated = [];
            for (const source of CSV_SOURCES) {
              let text = '';
              const candidates = Array.isArray(source.urls) && source.urls.length ? source.urls : [source.url];
              for (const rawUrl of candidates) {
                const url = encodeURI(rawUrl);
                try {
                  const res = await fetch(url);
                  if (!res.ok) continue;
                  text = await res.text();
                  if (text) text = text.replace(/^﻿/, '');
                  if (text) break;
                } catch (err) {
                  // try next candidate
                }
              }
              if (!text && source.embeddedText) {
                text = source.embeddedText;
              }
              if (text) text = text.replace(/^﻿/, '');
              if (!text) continue;

              const rows = parseCSV(text);
              const defaultTheme = source.defaults?.theme || '';
              const effectiveRows = source.limit ? rows.slice(0, source.limit) : rows;
              effectiveRows.forEach((row) => {
                const english = (row.word || row['word'] || row['english_word'] || row['英文'] || row['英文單字'] || row.word_lower || '').trim();
                if (!english) return;
                const themes = mergeThemes(row.themes, row['主題'], row['theme'], defaultTheme);
                const primaryTheme = themes.length ? themes[0] : defaultTheme;
                aggregated.push({
                  english_word: english,
                  kk_phonetic: row['KK音標'] || row['KK'] || '',
                  chinese_definition: row['中譯'] || row['definition'] || row['鍾意'] || '',
                  example_sentence: row['例句'] || row['sentence'] || row['ai例句'] || row['example_sentence'] || '',
                  example_translation: row['翻譯'] || row['translation'] || row['ai例句中譯'] || row['example_translation'] || '',
                  example_sentence_2: row['例句2'] || row['例句_2'] || row['sentence2'] || row['GSAT_Example_Sentence_1'] || row['example_sentence_2'] || '',
                  example_translation_2: row['翻譯2'] || row['翻譯_2'] || row['translation2'] || row['GSAT_Translation_1'] || row['example_translation_2'] || '',
                  example_sentence_3: row['例句3'] || row['例句_3'] || row['sentence3'] || row['example_sentence_3'] || '',
                  example_translation_3: row['翻譯3'] || row['翻譯_3'] || row['translation3'] || row['example_translation_3'] || '',
                  example_sentence_4: row['例句4'] || row['例句_4'] || row['sentence4'] || row['example_sentence_4'] || '',
                  example_translation_4: row['翻譯4'] || row['翻譯_4'] || row['translation4'] || row['example_translation_4'] || '',
                  example_sentence_5: row['例句5'] || row['例句_5'] || row['sentence5'] || row['example_sentence_5'] || '',
                  example_translation_5: row['翻譯5'] || row['翻譯_5'] || row['translation5'] || row['example_translation_5'] || '',
                  example_source_2: (() => {
                    const year = row['Year_1'] || row['N'] || '';
                    const part = row['Part_1'] || row['O'] || '';
                    const source = row['Source_1'] || row['P'] || '';
                    if (year && part && source) {
                      return `${year}\t${part}\t${source}`;
                    }
                    return '';
                  })(),
                  grammar_main_category: row['詞性'] || row['副詞'] || row['pos'] || '',
                  grammar_sub_category: row['詞性分類'] || row['子分類'] || row['subcat'] || '',
                  theme: primaryTheme || '',
                  themes,
                  default_theme: defaultTheme,
                  level: row['level'] || row['Level'] || row['LEVEL'] || '',
                  cefr: row['CEFR'] || row['cefr'] || '',
                  word_forms: row['詞性變化'] || row['詞形變化'] || row['詞形說明'] || row['word_forms'] || '',
                  derivatives: row['衍生詞'] || row['derivatives'] || '',
                  synonyms: row['同義字'] || row['synonyms'] || '',
                  antonyms: row['反義字'] || row['antonyms'] || '',
                  confusables: row['易混淆字'] || row['confusables'] || '',
                  phrases: (row['片語'] || row['phrases'] || '').split(/[;；]/).map(p => p.trim()).filter(p => p),
                  word_forms_detail: row['word_forms_detail'],
                  affix_info: {
                    prefix: row['字首'] || row['prefix'] || '',
                    root: row['字根'] || row['root'] || '',
                    suffix: row['字尾'] || row['suffix'] || '',
                    meaning: row['意思'] || row['meaning'] || '',
                    example: row['例子'] || row['example'] || ''
                  }
                });
              });
            }
            if (!cancelled && aggregated.length) {
              addItems(aggregated, { overrideExamples: false, replace: true });
              try { localStorage.setItem(LS.presetApplied, PRESET_VERSION); } catch {}
            }
          };
          ensureCsvPreset();
          return () => { cancelled = true; };
        }, []);

        return { data, addItems, reset };
      };

      const useFavorites = () => {
        const [favorites, setFavorites] = useState(() => {
          try {
            const raw = localStorage.getItem(LS.favorites);
            return raw ? JSON.parse(raw) : [];
          } catch {
            return [];
          }
        });
        useEffect(() => {
          try { localStorage.setItem(LS.favorites, JSON.stringify(favorites)); } catch {}
        }, [favorites]);
        return {
          favorites,
          toggle: (id) => setFavorites((cur) => cur.includes(id) ? cur.filter((x) => x !== id) : [...cur, id]),
          remove: (id) => setFavorites((cur) => cur.filter((x) => x !== id)),
          clear: () => setFavorites([])
        };
      };

      // 管理使用者自訂例句的 hook
      const useUserExamples = () => {
        const [userExamples, setUserExamples] = useState(() => {
          try {
            const raw = localStorage.getItem(LS.userExamples);
            return raw ? JSON.parse(raw) : {};
          } catch {
            return {};
          }
        });
        
        useEffect(() => {
          try { 
            localStorage.setItem(LS.userExamples, JSON.stringify(userExamples)); 
          } catch (e) {
            console.error('無法儲存使用者例句:', e);
          }
        }, [userExamples]);
        
        return {
          // 取得某個單字的使用者例句
          get: (wordId) => {
            return userExamples[wordId] || [];
          },
          // 新增例句
          add: (wordId, sentence, translation) => {
            setUserExamples((cur) => {
              const existing = cur[wordId] || [];
              return {
                ...cur,
                [wordId]: [...existing, { 
                  sentence: sentence.trim(), 
                  translation: translation.trim(),
                  source: 'user',
                  createdAt: new Date().toISOString()
                }]
              };
            });
          },
          // 刪除例句
          remove: (wordId, exampleIndex) => {
            setUserExamples((cur) => {
              const existing = cur[wordId] || [];
              const updated = existing.filter((_, idx) => idx !== exampleIndex);
              if (updated.length === 0) {
                const newState = { ...cur };
                delete newState[wordId];
                return newState;
              }
              return { ...cur, [wordId]: updated };
            });
          },
          // 清空某個單字的所有使用者例句
          clearWord: (wordId) => {
            setUserExamples((cur) => {
              const newState = { ...cur };
              delete newState[wordId];
              return newState;
            });
          },
          // 清空所有使用者例句
          clearAll: () => {
            setUserExamples({});
          }
        };
      };

      // 管理測驗歷史記錄的 hook
      const useQuizHistory = () => {
        const MAX_HISTORY = 50;
        
        const [history, setHistory] = useState(() => {
          try {
            const raw = localStorage.getItem(LS.quizHistory);
            return raw ? JSON.parse(raw) : [];
          } catch {
            return [];
          }
        });
        
        useEffect(() => {
          try {
            localStorage.setItem(LS.quizHistory, JSON.stringify(history));
          } catch (e) {
            console.error('無法儲存測驗歷史:', e);
          }
        }, [history]);
        
        return {
          // 取得所有記錄
          getAll: () => {
            return [...history].sort((a, b) => new Date(b.date) - new Date(a.date));
          },
          // 新增記錄
          add: (record) => {
            setHistory((cur) => {
              const newRecord = {
                ...record,
                id: record.id || new Date().toISOString(),
                date: record.date || new Date().toISOString()
              };
              const updated = [newRecord, ...cur].slice(0, MAX_HISTORY);
              return updated;
            });
          },
          // 刪除單筆記錄
          remove: (id) => {
            setHistory((cur) => cur.filter((r) => r.id !== id));
          },
          // 清除所有記錄
          clearAll: () => {
            setHistory([]);
          },
          // 取得單筆記錄
          get: (id) => {
            return history.find((r) => r.id === id);
          }
        };
      };

      const Importer = ({ onImport, className = "" }) => {
        const [msg, setMsg] = useState("");
        const [paste, setPaste] = useState("");
        const [dragOver, setDragOver] = useState(false);
        const [override, setOverride] = useState(true);
        const inputRef = useRef(null);

        const posSummary = (stats) => Object.entries(stats.tagsAdded || {}).map(([k, v]) => `${POS_LABEL[k] || k}:${v}`).join('、');

        const importText = async (rawText, hint) => {
          const text = String(rawText || "").replace(/^\uFEFF/, "").trim();
          if (!text) { setMsg("匯入失敗：內容為空"); return; }

          const tryJson = () => {
            try {
              const parsed = JSON.parse(text);
              if (Array.isArray(parsed)) {
                const stats = onImport(parsed, { overrideExamples: override, replace: false });
                const summary = posSummary(stats);
                setMsg(`已匯入 ${stats.added + stats.merged} 筆（${hint}JSON），新增單字 ${stats.added}，合併 ${stats.merged}${summary ? `，新增標籤 ${summary}` : ""}。`);
                return true;
              }
            } catch {}
            return false;
          };

          if (tryJson()) return;
          const rows = parseCSV(text);
          if (!rows.length) { setMsg("匯入失敗：內容不是有效的 JSON 或 CSV"); return; }
          const stats = onImport(rows, { overrideExamples: override, replace: false });
          const summary = posSummary(stats);
          setMsg(`已匯入 ${stats.added + stats.merged} 筆（${hint}CSV），新增單字 ${stats.added}，合併 ${stats.merged}${summary ? `，新增標籤 ${summary}` : ""}。`);
        };

        const onInputChange = (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => { importText(reader.result, `${file.name}/`); };
          reader.onerror = () => { setMsg(`匯入失敗：無法讀取檔案 ${file.name}`); };
          reader.readAsText(file);
          e.target.value = "";
        };

        const onDrop = (e) => {
          e.preventDefault();
          setDragOver(false);
          const file = e.dataTransfer?.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => { importText(reader.result, `${file.name}/`); };
          reader.onerror = () => { setMsg(`匯入失敗：無法讀取檔案 ${file.name}`); };
          reader.readAsText(file);
        };

        return (
          <div
            className={`rounded-2xl border p-4 bg-white/60 ${dragOver ? 'ring-2 ring-indigo-400' : ''} ${className}`}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onDrop={onDrop}
          >
            <div className="font-semibold mb-2">資料匯入（JSON/CSV）</div>
            <p className="text-sm text-gray-600 mb-3">三種方式：① 選擇檔案 ② 拖曳到此區 ③ 直接貼上文字</p>

            <div className="flex flex-wrap items-center gap-3 mb-3">
              <input ref={inputRef} type="file" accept="application/json,.json,.csv,text/csv,text/plain" className="hidden" onChange={onInputChange} />
              <Button variant="ghost" onClick={() => inputRef.current?.click()}>選擇 JSON 或 CSV 檔</Button>
              <label className="flex items-center gap-1 text-xs text-gray-600">
                <input type="checkbox" className="mr-1" checked={override} onChange={(e) => setOverride(e.target.checked)} />
                匯入例句／翻譯時覆蓋現有內容
              </label>
              <span className="text-xs text-gray-500">或拖曳檔案至此</span>
            </div>

            <div className="mt-2">
              <textarea
                value={paste}
                onChange={(e) => setPaste(e.target.value)}
                placeholder="或直接貼上 JSON / CSV 文字..."
                className="w-full h-28 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              />
              <div className="mt-2">
                <Button variant="ghost" onClick={() => importText(paste, '貼上/')}>匯入貼上的內容</Button>
              </div>
            </div>

          {msg && <div className="text-xs text-gray-500 mt-2">{msg}</div>}
        </div>
        );
      };

      const Shell = ({ children, onReset }) => {
        const handleReload = () => {
          if (confirm('確定要重新從 Google Sheets 載入資料嗎？\n（這會清除本地快取）')) {
            localStorage.removeItem('mvp_vocab_dataset_v36');
            localStorage.removeItem('mvp_vocab_preset_applied_v36');
            window.location.reload();
          }
        };
        
        // 檢測是否有錯題測驗狀態
        const [hasWrongWords, setHasWrongWords] = useState(() => {
          try {
            const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
            return wrongWordIds.length > 0;
          } catch {
            return false;
          }
        });
        
        // 監聽 localStorage 變化
        useEffect(() => {
          const checkWrongWords = () => {
            try {
              const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
              setHasWrongWords(wrongWordIds.length > 0);
            } catch {
              setHasWrongWords(false);
            }
          };
          
          // 初始檢查
          checkWrongWords();
          
          // 監聽 storage 事件（當其他標籤頁修改 localStorage 時）
          window.addEventListener('storage', checkWrongWords);
          
          // 定期檢查（因為同頁面的 localStorage 修改不會觸發 storage 事件）
          const interval = setInterval(checkWrongWords, 1000);
          
          return () => {
            window.removeEventListener('storage', checkWrongWords);
            clearInterval(interval);
          };
        }, []);
        
        return (
          <div className="min-h-screen bg-gradient-to-b from-indigo-50 to-white">
            <div className="max-w-5xl mx-auto px-4 py-6">
              <header className="flex items-center justify-between mb-6">
                <a href="#/" className="text-2xl font-bold tracking-tight"> WordGym 單字健身坊 </a>
                <nav className="flex gap-2 items-center">
                  <a href="#/" className="px-3 py-2 rounded-lg hover:bg-gray-100">首頁</a>
                  <a href="#/favorites" className="px-3 py-2 rounded-lg hover:bg-gray-100">重點訓練</a>
                  <a href="#/quiz" className="px-3 py-2 rounded-lg hover:bg-gray-100">實力驗收</a>
                  {hasWrongWords && (
                    <a 
                      href="#/quiz?source=wrong-words&type=multiple-choice" 
                      className="px-3 py-2 rounded-lg hover:bg-red-100 bg-red-50 text-red-700 font-medium"
                      title="回到錯題測驗"
                    >
                      🔴 錯題測驗
                    </a>
                  )}
                  <button 
                    onClick={handleReload}
                    className="px-3 py-2 rounded-lg hover:bg-indigo-100 text-indigo-600 text-sm font-medium"
                    title="從 Google Sheets 重新載入資料"
                  >
                    🔄 重新載入
                  </button>
                </nav>
              </header>
              {children}
              <footer className="mt-12 text-center text-xs text-gray-400">學生自學版 • v5.2</footer>
            </div>
          </div>
        );
      };

      const Home = ({ push, data, onImport }) => {
        const [isLoading, setIsLoading] = useState(false);
        const [loadError, setLoadError] = useState(null);
        
        // 自動載入 Google Sheets
        useEffect(() => {
          const autoLoad = async () => {
            console.log('=== 自動載入檢查 ===');
            console.log('目前資料數量:', data.length);
            console.log('Google Sheets 啟用:', GOOGLE_SHEET_CONFIG.enabled);
            
            if (data.length > 0) {
              console.log('已有資料，跳過載入');
              return;
            }
            if (!GOOGLE_SHEET_CONFIG.enabled) {
              console.log('Google Sheets 未啟用');
              return;
            }
            
            console.log('開始載入 Google Sheets...');
            setIsLoading(true);
            setLoadError(null);
            
            try {
              const results = await loadAllGoogleSheets();
              console.log('載入結果:', results);
              for (const { rows, theme } of results) {
                console.log(`匯入 ${rows.length} 筆資料，主題:`, theme);
                onImport(rows, theme);
              }
              console.log('載入完成！');
            } catch (error) {
              console.error('載入失敗:', error);
              setLoadError(error.message);
            } finally {
              setIsLoading(false);
            }
          };
          
          autoLoad();
        }, []);
        
        const saved = useMemo(() => {
          try { return JSON.parse(localStorage.getItem(LS.homeFilters) || '{}'); } catch { return {}; }
        }, []);
        const [q, setQ] = useState(saved.q || "");
        const [selectedTheme, setSelectedTheme] = useState(saved.theme || "all");
        const [selectedPOS, setSelectedPOS] = useState(saved.pos || "all");
        const [selectedLevels, setSelectedLevels] = useState(saved.levels || []);
        useEffect(() => {
          try { localStorage.setItem(LS.homeFilters, JSON.stringify({ q, theme: selectedTheme, pos: selectedPOS, levels: selectedLevels })); } catch {}
        }, [q, selectedTheme, selectedPOS, selectedLevels]);
        
        const themes = useMemo(() => ALL_THEMES.map(k => ({ 
          key: k, 
          count: data.filter((w) => {
            // 檢查是否有對應的主題
            if (wordHasTheme(w, k)) return true;
            // 特別處理 highschool_climate 主題，檢查是否有「氣候」主題
            if (k === 'highschool_climate') {
              const wordThemes = getWordThemes(w);
              return wordThemes.includes('氣候') || wordThemes.includes('climate');
            }
            return false;
          }).length 
        })), [data]);
        const levels = useMemo(() => {
          const set = new Set();
          data.forEach((w)=>{ const lv = String(w.level||'').trim(); if(lv) set.add(lv); });
          return Array.from(set).sort((a,b)=> String(a).localeCompare(String(b)));
        }, [data]);

        const themeFilteredData = useMemo(() => {
          if (selectedTheme === "all") return data;
          const filtered = data.filter((w) => {
            // 檢查是否有對應的主題
            if (wordHasTheme(w, selectedTheme)) return true;
            // 特別處理 highschool_climate 主題，檢查是否有「氣候」主題
            if (selectedTheme === 'highschool_climate') {
              const wordThemes = getWordThemes(w);
              return wordThemes.includes('氣候') || wordThemes.includes('climate');
            }
            return false;
          });
          return [...filtered].sort((a, b) => {
            const orderA = a?.theme_order?.[selectedTheme];
            const orderB = b?.theme_order?.[selectedTheme];
            const safeA = Number.isFinite(orderA) ? orderA : Number.MAX_SAFE_INTEGER;
            const safeB = Number.isFinite(orderB) ? orderB : Number.MAX_SAFE_INTEGER;
            if (safeA !== safeB) return safeA - safeB;
            return String(a.english_word || '').localeCompare(String(b.english_word || ''));
          });
        }, [data, selectedTheme]);

        const categories = useMemo(() => ALL_POS.map(k => ({ key:k, count: themeFilteredData.filter(w=> (w.posTags||[]).includes(k)).length })), [themeFilteredData]);
        const totalForTheme = themeFilteredData.length;

        const filtered = useMemo(() => { 
          const s=q.trim().toLowerCase(); 
          let filteredData = themeFilteredData;
          
          if (selectedPOS !== "all") {
            filteredData = filteredData.filter(w => (w.posTags||[]).includes(selectedPOS));
          }
          if (selectedLevels.length > 0) {
            filteredData = filteredData.filter(w => selectedLevels.includes(String(w.level||'').trim()));
          }
          
          if(!s) return filteredData; 
          return filteredData.filter(w=>w.english_word.toLowerCase().includes(s)); 
        }, [q, themeFilteredData, selectedPOS, selectedLevels]);
        const selectedPosCount = useMemo(() => {
          if (selectedPOS === "all") return totalForTheme;
          const match = categories.find((c) => c.key === selectedPOS);
          return match ? match.count : 0;
        }, [categories, selectedPOS, totalForTheme]);
        const themeLabel = selectedTheme === "all" ? "全部主題" : (THEME_LABEL[selectedTheme] || selectedTheme);
        const posLabel = selectedPOS === "all" ? `全部詞性 (${totalForTheme})` : `${POS_LABEL[selectedPOS] || selectedPOS} (${selectedPosCount})`;
        const levelLabel = selectedLevels.length === 0 ? "全部 Level" : `Level ${selectedLevels.join(', ')}`;
        const ensureLine = (text) => {
          const t = String(text || '').trim();
          return t ? t : '\u00A0';
        };
        const showTable = filtered.length > 0;
        return (
          <div>
            {/* 載入中 */}
            {isLoading && (
              <div className="mb-6 rounded-2xl border-2 border-indigo-200 bg-indigo-50 p-4 text-center">
                <div className="animate-pulse">
                  <div className="text-lg font-semibold text-indigo-700 mb-2">📥 正在從 Google Sheet 載入單字資料...</div>
                  <div className="text-sm text-indigo-600">請稍候</div>
                </div>
              </div>
            )}
            
            {/* 載入錯誤 */}
            {loadError && (
              <div className="mb-6 rounded-2xl border-2 border-red-200 bg-red-50 p-4">
                <div className="text-lg font-semibold text-red-700 mb-2">❌ 載入失敗</div>
                <div className="text-sm text-red-600 mb-3">{loadError}</div>
                <div className="text-xs text-gray-600">
                  請確認 Google Sheet 已設為「可檢視」或「發布至網路」
                </div>
              </div>
            )}
            
            <div className="text-gray-600 mb-6 leading-relaxed space-y-2">
              <p>歡迎來到 WordGym 單字健身坊！</p>
              <p>在開始訓練前，讓我們先了解你的需求。請從主題、詞性或 Level 選擇想要加強的項目，為你量身打造訓練清單！</p>
            </div>

            <div className="grid gap-4 md:grid-cols-3 mb-6">
              <div className="rounded-2xl border p-4 bg-white/70">
                <h2 className="text-lg font-semibold mb-3">主題篩選</h2>
                <div className="flex flex-wrap gap-2">
                  <Button 
                    variant={selectedTheme === "all" ? "primary" : "ghost"} 
                    onClick={() => setSelectedTheme("all")}
                  >
                    全選 ({data.length})
                  </Button>
                  {themes.map(t => (
                    <Button 
                      key={t.key} 
                      variant={selectedTheme === t.key ? "primary" : "ghost"} 
                      onClick={() => setSelectedTheme(t.key)}
                    >
                      {THEME_LABEL[t.key]} ({t.count})
                    </Button>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border p-4 bg-white/70">
                <h2 className="text-lg font-semibold mb-3">詞性篩選</h2>
                <div className="flex flex-wrap gap-2">
                  <Button 
                    variant={selectedPOS === "all" ? "primary" : "ghost"} 
                    onClick={() => setSelectedPOS("all")}
                  >
                    全選 ({totalForTheme})
                  </Button>
                  {categories.filter(c => c.count > 0).map(c => (
                    <Button 
                      key={c.key} 
                      variant={selectedPOS === c.key ? "primary" : "ghost"} 
                      onClick={() => setSelectedPOS(c.key)}
                    >
                      {POS_LABEL[c.key]} ({c.count})
                    </Button>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border p-4 bg-white/70">
                <h2 className="text-lg font-semibold mb-3">Level 篩選</h2>
                <div className="flex flex-wrap gap-2">
                  <Button 
                    variant={selectedLevels.length === 0 ? "primary" : "ghost"} 
                    onClick={() => setSelectedLevels([])}
                  >
                    全選 ({totalForTheme})
                  </Button>
                  {levels.map((lv)=> (
                    <Button 
                      key={lv} 
                      variant={selectedLevels.includes(lv) ? "primary" : "ghost"} 
                      onClick={() => {
                        if (selectedLevels.includes(lv)) {
                          setSelectedLevels(selectedLevels.filter(l => l !== lv));
                        } else {
                          setSelectedLevels([...selectedLevels, lv]);
                        }
                      }}
                    >
                      {lv} ({themeFilteredData.filter(w => String(w.level||'').trim() === lv).length})
                    </Button>
                  ))}
                </div>
              </div>
            </div>

            <div className="mb-6 flex flex-col sm:flex-row items-start sm:items-center gap-3">
              <input 
                value={q} 
                onChange={(e)=>setQ(e.target.value)} 
                placeholder="搜尋單字..." 
                className="w-full sm:flex-1 px-4 py-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" 
              />
              {(selectedTheme !== "all" || selectedPOS !== "all" || selectedLevels.length > 0 || q) && (
                <Button 
                  variant="ghost" 
                  onClick={()=>{ setSelectedTheme("all"); setSelectedPOS("all"); setSelectedLevels([]); setQ(""); }}
                  className="whitespace-nowrap"
                >
                  清除篩選
                </Button>
              )}
            </div>
            
            <div className="mt-6 space-y-4">
              <div className="flex flex-wrap items-baseline justify-between gap-3">
                <div>
                  <h2 className="text-xl font-semibold">{themeLabel} · {posLabel} · {levelLabel}</h2>
                  <p className="text-sm text-gray-500">符合條件的單字：{filtered.length} 筆{q ? `（含搜尋「${q}」）` : ''}</p>
                </div>
              </div>
              <div className="overflow-x-auto rounded-2xl border border-gray-200 bg-white/80 shadow-sm">
                {!showTable ? (
                  <p className="px-4 py-6 text-sm text-gray-500">找不到符合條件的單字，請調整主題、詞性或搜尋條件。</p>
                ) : (
                  <table className="min-w-full text-sm">
                    <thead className="bg-indigo-50 text-xs uppercase tracking-wide text-indigo-700">
                      <tr>
                        <th className="px-4 py-3 text-left font-semibold">Level</th>
                        <th className="px-4 py-3 text-left font-semibold">單字</th>
                        <th className="px-4 py-3 text-left font-semibold">音標</th>
                        <th className="px-4 py-3 text-left font-semibold">中譯</th>
                        <th className="px-4 py-3 text-left font-semibold">例句</th>
                        <th className="px-4 py-3 text-left font-semibold">翻譯</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-gray-200">
                      {filtered.map((w) => {
                        const posText = (w.posTags||[]).map(p=>POS_LABEL[p]||p).join('、') || '—';
                        const examples = [ensureLine(w.example_sentence), ensureLine(w.example_sentence_2)];
                        const translations = [ensureLine(w.example_translation), ensureLine(w.example_translation_2)];
                        const themeLabels = getThemeDisplayLabels(w);
                        const themeDisplay = themeLabels.length ? themeLabels.join(' / ') : '—';
                        return (
                          <tr key={w.id} className="align-top">
                            <td className="px-4 py-4 whitespace-nowrap align-top text-center">
                              <span className="inline-flex items-center justify-center w-8 h-8 rounded-full bg-indigo-100 text-indigo-700 font-semibold text-sm">
                                {w.level || '—'}
                              </span>
                            </td>
                            <td className="px-4 py-4 whitespace-nowrap align-top">
                              <a href={`#/word/${w.id}`} className="text-base font-semibold text-indigo-700 hover:underline">
                                {w.english_word}
                              </a>
                              <div className="mt-1 text-xs text-gray-500">{posText}</div>
                              <div className="mt-1 text-xs text-gray-400">{themeDisplay}</div>
                            </td>
                            <td className="px-4 py-4 whitespace-nowrap align-top text-gray-700">{w.kk_phonetic || '—'}</td>
                            <td className="px-4 py-4 align-top text-gray-800 whitespace-pre-wrap">{w.chinese_definition || '—'}</td>
                            <td className="px-4 py-4 align-top text-gray-700">
                              {examples.map((line, idx) => (
                                <div key={`ex-${w.id}-${idx}`} className="min-h-[1.5rem] whitespace-pre-wrap leading-relaxed">
                                  {line}
                                </div>
                              ))}
                            </td>
                            <td className="px-4 py-4 align-top text-gray-700">
                              {translations.map((line, idx) => (
                                <div key={`tr-${w.id}-${idx}`} className="min-h-[1.5rem] whitespace-pre-wrap leading-relaxed">
                                  {line}
                                </div>
                              ))}
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                )}
              </div>
            </div>
          </div>
        );
      };

      const CategoryList = ({ cat, data }) => {
        const list = data.filter(w => (w.posTags||[]).includes(cat));
        return (
          <div>
            <h1 className="text-2xl font-bold mb-4">{POS_LABEL[cat] || cat || '—'}（{list.length}）</h1>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {list.map(w => (
                <a key={w.id} href={`#/word/${w.id}`} className="block rounded-xl border p-3 hover:shadow">
                  <div className="font-semibold">{w.english_word}</div>
                  <div className="text-xs text-gray-500">{(w.posTags||[]).join(', ')}</div>
                </a>
              ))}
            </div>
          </div>
        );
      };

      const WordDetail = ({ id, data, favoritesApi, userExamplesApi, push, prevRoute }) => {
        const word = data.find((w) => String(w.id) === String(id));
        const [selPos, setSelPos] = useState(word?.posTags?.[0] || "other");
        const [mdPreview, setMdPreview] = useState('');
        const [mdStatus, setMdStatus] = useState('');
        const [showMdPreview, setShowMdPreview] = useState(false);
        const [exportSections, setExportSections] = useState({ pos: true, relations: true, affix: true });
        const [showAddExample, setShowAddExample] = useState(false);
        const [newExampleEn, setNewExampleEn] = useState('');
        const [newExampleZh, setNewExampleZh] = useState('');

        // 提取 YouTube 影片 ID
        const getYouTubeId = (url) => {
          if (!url) return null;
          const patterns = [
            /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\?\/]+)/,
            /youtube\.com\/watch\?.*v=([^&]+)/
          ];
          for (const pattern of patterns) {
            const match = url.match(pattern);
            if (match) return match[1];
          }
          return null;
        };
        
        const videoId = word ? getYouTubeId(word.videoUrl) : null;

        // 除錯：顯示 videoUrl 資訊
        React.useEffect(() => {
          if (word && word.english_word === 'conservation') {
            console.log('=== Conservation 單字資料除錯 ===');
            console.log('單字:', word.english_word);
            console.log('videoUrl 欄位值:', word.videoUrl);
            console.log('提取的 videoId:', videoId);
            console.log('完整單字物件:', word);
          }
        }, [word]);

        // 合併 CSV 和使用者例句的函數
        const getAllExamples = (word) => {
          const examples = [];
          
          // 除錯：檢查 word 物件是否有例句3-5
          if (word.english_word === 'air' || word.english_word === 'fall' || word.english_word === 'blow') {
            console.log(`=== ${word.english_word} 例句檢查 ===`);
            console.log('example_sentence:', word.example_sentence);
            console.log('example_sentence_2:', word.example_sentence_2);
            console.log('example_sentence_3:', word.example_sentence_3);
            console.log('example_sentence_4:', word.example_sentence_4);
            console.log('example_sentence_5:', word.example_sentence_5);
          }
          
          // 從 CSV 讀取例句（1-5）
          for (let i = 1; i <= 5; i++) {
            const sentenceKey = i === 1 ? 'example_sentence' : `example_sentence_${i}`;
            const translationKey = i === 1 ? 'example_translation' : `example_translation_${i}`;
            
            const sentence = (word[sentenceKey] || '').trim();
            const translation = (word[translationKey] || '').trim();
            
            // 只要有任何一個欄位有內容就保留
            if (sentence || translation) {
              // 只有例句2有出處資訊
              const sourceInfo = (i === 2 && word.example_source_2) ? word.example_source_2.trim() : '';
              
              examples.push({
                sentence,
                translation,
                source: 'csv',
                sourceInfo,
                index: i
              });
            }
          }
          
          if (word.english_word === 'air' || word.english_word === 'fall' || word.english_word === 'blow') {
            console.log('收集到的例句數量:', examples.length);
            console.log('例句列表:', examples);
          }
          
          // 從 localStorage 讀取使用者例句
          const userExamples = userExamplesApi.get(word.id);
          userExamples.forEach((ex, idx) => {
            examples.push({
              sentence: ex.sentence,
              translation: ex.translation,
              source: 'user',
              sourceInfo: '',
              userIndex: idx
            });
          });
          
          // 限制最多 5 個
          return examples.slice(0, 5);
        };

        const allExamples = word ? getAllExamples(word) : [];
        const canAddMore = allExamples.length < 5;

        // 新增例句的處理函數
        const handleAddExample = () => {
          if (!newExampleEn.trim() && !newExampleZh.trim()) {
            alert('請至少輸入英文或中文例句');
            return;
          }
          userExamplesApi.add(word.id, newExampleEn, newExampleZh);
          setNewExampleEn('');
          setNewExampleZh('');
          setShowAddExample(false);
        };

        // 刪除例句的處理函數
        const handleDeleteExample = (example) => {
          if (example.source === 'user' && example.userIndex !== undefined) {
            if (confirm('確定要刪除這個例句嗎？')) {
              userExamplesApi.remove(word.id, example.userIndex);
            }
          }
        };

        useEffect(() => {
          setMdStatus('');
          setShowMdPreview(false);
          setMdPreview('');
          setShowAddExample(false);
          setNewExampleEn('');
          setNewExampleZh('');
        }, [selPos, word?.id]);

        useEffect(() => {
          setExportSections({ pos: true, relations: true, affix: true });
        }, [word?.id]);

        useEffect(() => {
          if (!word) return;
          const nextPos = Array.isArray(word.posTags) && word.posTags.length ? word.posTags[0] : 'other';
          setSelPos(nextPos);
        }, [word?.id]);

        if (!word) return <div>找不到單字。</div>;

        const posTags = Array.isArray(word.posTags) && word.posTags.length ? word.posTags : ['other'];
        const posTextFull = posTags.map((tag) => POS_LABEL[tag] || tag);
        const themeKeys = getWordThemes(word);
        const themeLabels = getThemeDisplayLabels(word);
        const primaryThemeLabel = themeLabels[0] || '—';
        const levelText = String(word.level ?? '').trim();
        const isFav = favoritesApi.favorites.includes(word.id);

        const auto = grammarDefaults(word.english_word, selPos, word.grammar_sub_category);
        const gFunc = (word.grammar_function || '').trim() || auto.grammar_function;
        const gPattern = (word.applicable_sentence_pattern || '').trim() || auto.sentence_pattern;

        const wfDetailRaw = word.word_forms_detail || emptyWordFormsDetail();
        const wfDetail = {
          base: Array.isArray(wfDetailRaw.base) ? wfDetailRaw.base : [],
          idiom: Array.isArray(wfDetailRaw.idiom) ? wfDetailRaw.idiom : [],
          compound: Array.isArray(wfDetailRaw.compound) ? wfDetailRaw.compound : [],
          derivation: Array.isArray(wfDetailRaw.derivation) ? wfDetailRaw.derivation : []
        };
        
        // 詞性變化資料會在渲染時直接顯示

        const clean = (value) => String(value || '').trim();
        const primaryExampleEn = clean(word.example_sentence);
        const primaryExampleZh = clean(word.example_translation);
        const secondaryExampleEn = clean(word.example_sentence_2);
        const secondaryExampleZh = clean(word.example_translation_2);
        const secondaryExampleSource = clean(word.example_source_2);
        
        // 除錯：檢查資料載入狀況
        if (word.english_word === 'air') {
          console.log('Air 單字資料檢查:', {
            english_word: word.english_word,
            example_sentence: word.example_sentence,
            example_sentence_2: word.example_sentence_2,
            example_source_2: word.example_source_2,
            secondaryExampleSource: secondaryExampleSource,
            rawData: word
          });
        }
        const fallbackExample = exampleFor(word.english_word, selPos);
        const fallbackTranslation = translationFor(word.english_word, selPos);

        const exampleCards = [
          { en: primaryExampleEn, zh: primaryExampleZh, allowFallback: true, source: '' },
          { en: secondaryExampleEn, zh: secondaryExampleZh, allowFallback: false, source: secondaryExampleSource }
        ];

        const synonyms = Array.isArray(word.synonyms) ? word.synonyms : multiSplit(word.synonyms || '');
        const antonyms = Array.isArray(word.antonyms) ? word.antonyms : multiSplit(word.antonyms || '');
        const confusables = Array.isArray(word.confusables) ? word.confusables : multiSplit(word.confusables || '');
        const hasSynonymBlock = synonyms.length || antonyms.length || confusables.length;

        const affix = word.affix_info || {};
        const affixInfo = {
          prefix: clean(affix.prefix),
          root: clean(affix.root),
          suffix: clean(affix.suffix),
          meaning: clean(affix.meaning),
          example: clean(affix.example)
        };
        const hasAffixInfo = affixInfo.prefix || affixInfo.suffix || affixInfo.root;

        const exportExample1 = primaryExampleEn || fallbackExample;
        const exportTranslation1 = primaryExampleZh || fallbackTranslation;
        const exportExample2 = secondaryExampleEn;
        const exportTranslation2 = secondaryExampleZh;

        const handleOutput = async () => {
          const md = wordToMarkdown(word, selPos, {
            example_sentence: exportExample1,
            example_translation: exportTranslation1,
            example_sentence_2: exportExample2,
            example_translation_2: exportTranslation2,
            grammar_function: gFunc,
            applicable_sentence_pattern: gPattern,
            grammar_sub_category: word.grammar_sub_category,
            word_forms: word.word_forms,
            derivatives: word.derivatives,
            synonyms: word.synonyms,
            antonyms: word.antonyms,
            confusables: word.confusables,
            affix_info: word.affix_info,
            sections: exportSections
          });
          setMdPreview(md);
          if (!md || !md.trim()) {
            setMdStatus('此單字目前沒有可輸出的內容。');
            setShowMdPreview(false);
            return;
          }
          try {
            if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(md);
              setMdStatus('已複製 Markdown，可貼到 Google 文件或投影片。');
              setShowMdPreview(false);
              return;
            }
            throw new Error('clipboard not available');
          } catch (err) {
            setMdStatus('無法自動複製，請手動複製下方內容。');
            setShowMdPreview(true);
          }
        };

        // 檢測是否有錯題測驗狀態（動態檢測）
        const [hasWrongWords, setHasWrongWords] = useState(() => {
          try {
            const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
            return wrongWordIds.length > 0;
          } catch {
            return false;
          }
        });
        
        useEffect(() => {
          const checkWrongWords = () => {
            try {
              const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
              setHasWrongWords(wrongWordIds.length > 0);
            } catch {
              setHasWrongWords(false);
            }
          };
          
          // 初始檢查
          checkWrongWords();
          
          // 定期檢查（確保狀態同步）
          const interval = setInterval(checkWrongWords, 500);
          
          return () => clearInterval(interval);
        }, []);
        
        const goBack = () => {
          // 1. 優先檢查是否從測驗完成頁面來的
          try {
            const quizReturn = JSON.parse(sessionStorage.getItem('quiz_return_path') || 'null');
            if (quizReturn && quizReturn.timestamp && Date.now() - quizReturn.timestamp < 3600000) {
              // 1小時內有效
              sessionStorage.removeItem('quiz_return_path');
              push(quizReturn.path);
              return;
            }
          } catch {}
          
          // 2. 檢查錯題測驗狀態，如果有錯題就返回錯題測驗
          try {
            const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
            if (wrongWordIds.length > 0) {
              push('#/quiz?source=wrong-words&type=multiple-choice');
              return;
            }
          } catch {}
          
          // 3. 如果從 quiz 頁面進入，返回 quiz 頁面
          if (prevRoute && prevRoute.route === 'quiz') {
            push('#/quiz');
            return;
          }
          
          // 4. 其他情況使用原有邏輯
          if (prevRoute && prevRoute.route) {
            if (prevRoute.route === 'category' && prevRoute.param) { push(`#/category/${prevRoute.param}`); return; }
            if (prevRoute.route === 'favorites') { push('#/favorites'); return; }
            if (prevRoute.route === 'word' && prevRoute.param) { push(`#/word/${prevRoute.param}`); return; }
            if (prevRoute.route === 'home') { push('#/'); return; }
          }
          push('#/');
        };

        // 解析來源資訊
        const formatSource = (source) => {
          if (!source) return '';
          const parts = source.split('\t');
          if (parts.length === 3) {
            return `${parts[0]} ${parts[1]} ${parts[2]}`;
          }
          return source;
        };

        const renderExampleCard = (example, idx) => {
          const fallbackExample = exampleFor(word.english_word, selPos);
          const fallbackTranslation = translationFor(word.english_word, selPos);
          
          // 第一個例句如果為空可以使用 fallback
          const useFallback = idx === 0 && !example.sentence;
          const enText = example.sentence || (useFallback ? fallbackExample : '');
          const zhText = example.translation || (useFallback ? fallbackTranslation : '');
          const speakText = enText;
          
          // 如果沒有內容就不顯示
          if (!enText && !zhText && !useFallback) {
            return null;
          }
          
          return (
            <div key={`example-${idx}`} className="rounded-2xl bg-indigo-50 px-4 py-3 relative">
              <div className="flex items-start gap-2">
                <div className="flex-1 text-base text-gray-900 whitespace-pre-wrap">{enText || ' '}</div>
                <div className="flex items-center gap-2">
                  {speakText ? (
                    <SpeakerButton
                      onClick={() => speak(speakText)}
                      label={`播放例句 ${idx + 1} 發音`}
                      className="mt-0.5"
                    />
                  ) : null}
                  {example.source === 'user' && (
                    <button
                      onClick={() => handleDeleteExample(example)}
                      className="h-8 w-8 rounded-full border border-rose-200 bg-white text-rose-600 hover:bg-rose-50 hover:text-rose-700 transition flex items-center justify-center"
                      title="刪除例句"
                    >
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className="h-4 w-4">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  )}
                </div>
              </div>
              <div className="mt-2 text-sm text-indigo-800 whitespace-pre-wrap">{zhText || ' '}</div>
              {useFallback && (
                <div className="mt-2 text-xs text-gray-500">（系統預設例句，尚未補入原始資料）</div>
              )}
              {example.source === 'user' && (
                <div className="mt-2 text-xs text-emerald-600 font-medium">✏️ 我的例句</div>
              )}
              {/* 例句1：顯示「基礎例句」 */}
              {example.source === 'csv' && example.index === 1 && (
                <div className="mt-2 text-xs text-gray-500 text-right">基礎例句</div>
              )}
              {/* 例句2：顯示 CSV 出處 */}
              {example.source === 'csv' && example.index === 2 && example.sourceInfo && (
                <div className="mt-2 text-xs text-gray-500 text-right">{formatSource(example.sourceInfo)}</div>
              )}
            </div>
          );
        };

        const renderTagPill = (items, classes) => (
          <div className="flex flex-wrap gap-2">
            {items.map((item, idx) => (
              <span key={`${classes}-${idx}`} className={`px-3 py-1 rounded-full ${classes}`}>{item}</span>
            ))}
          </div>
        );

        const toggleExportSection = (key) => {
          setExportSections((prev) => ({ ...prev, [key]: !prev[key] }));
        };

        return (
          <div className="space-y-6">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div className="flex items-center gap-2">
                  <Button variant="ghost" onClick={goBack}>← 返回</Button>
                  {(() => {
                    try {
                      const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
                      if (wrongWordIds.length > 0) {
                        return (
                          <a 
                            href="#/quiz?source=wrong-words&type=multiple-choice"
                            className="px-3 py-2 rounded-lg hover:bg-red-100 bg-red-50 text-red-700 text-sm font-medium"
                            title="返回錯題測驗"
                          >
                            🔴 返回錯題測驗
                          </a>
                        );
                      }
                    } catch {
                      // 忽略錯誤
                    }
                    return null;
                  })()}
                  <span className="text-xs text-gray-500">{themeLabels.length ? themeLabels.join(' / ') : '—'}</span>
                </div>
                <div className="flex gap-2">
                  <Button variant={isFav ? 'danger' : 'primary'} onClick={() => favoritesApi.toggle(word.id)}>{isFav ? '移除重點訓練' : '加入重點訓練'}</Button>
                </div>
              </div>

            <div className="rounded-3xl border border-gray-200 bg-white/90 p-6 shadow-sm space-y-6">
              {/* 單字標題區塊 - 使用 flex 佈局 */}
              <div className="flex flex-col lg:flex-row gap-6">
                {/* 左側：單字資訊 */}
                <div className="flex-1">
                  <div className="flex items-center gap-3">
                    <h1 className="text-4xl font-bold text-gray-900">{word.english_word}</h1>
                    <SpeakerButton label="播放單字發音" onClick={() => speak(word.english_word)} />
                  </div>
                  <div className="mt-3 flex flex-wrap items-center gap-2 text-sm text-gray-600">
                    <span className="rounded-full bg-indigo-50 px-3 py-1 text-indigo-600">{POS_LABEL[selPos] || selPos}</span>
                    {levelText && <span className="rounded-full bg-amber-50 px-3 py-1 text-amber-600">Level {levelText}</span>}
                    {word.cefr && <span className="rounded-full bg-purple-50 px-3 py-1 text-purple-600">{word.cefr}</span>}
                    {themeLabels.map((label, idx) => (
                      <span key={`theme-${idx}`} className="rounded-full bg-gray-100 px-3 py-1 text-gray-600">{label}</span>
                    ))}
                    {word.grammar_sub_category && <span className="rounded-full bg-emerald-50 px-3 py-1 text-emerald-600">{word.grammar_sub_category}</span>}
                  </div>
                  {word.kk_phonetic && <div className="mt-4 text-lg font-medium text-indigo-700">{word.kk_phonetic}</div>}
                  {posTags.length > 1 && (
                    <div className="mt-4 flex flex-wrap gap-2 text-xs">
                      {posTags.map((tag) => (
                        <button
                          key={tag}
                          onClick={() => setSelPos(tag)}
                          className={`px-3 py-1 rounded-full border transition ${selPos === tag ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-gray-600 border-gray-200 hover:border-indigo-400'}`}
                        >
                          {POS_LABEL[tag] || tag}
                        </button>
                      ))}
                    </div>
                  )}
                </div>
                
                {/* 右側：影片區塊 - 固定寬度並垂直置中 */}
                {videoId && (
                  <div className="lg:w-80 flex items-center">
                    <div className="w-full rounded-xl overflow-hidden border border-gray-200 bg-gray-50 shadow-sm">
                      <div className="relative" style={{ paddingBottom: '56.25%' }}>
                        <iframe
                          className="absolute top-0 left-0 h-full w-full"
                          src={`https://www.youtube.com/embed/${videoId}`}
                          title={`${word.english_word} 教學影片`}
                          frameBorder="0"
                          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                          allowFullScreen
                        />
                      </div>
                      <div className="px-3 py-2 text-xs text-center text-gray-600 bg-white border-t border-gray-200">
                        📹 教學影片
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div>
                <div className="text-sm font-semibold text-gray-500 uppercase tracking-wide">中譯</div>
                <div className="mt-2 text-lg text-gray-900 whitespace-pre-wrap">{word.chinese_definition || '—'}</div>
              </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <div className="text-sm font-semibold text-gray-500 uppercase tracking-wide">
                    例句 ({allExamples.length}/5)
                  </div>
                  {canAddMore && !showAddExample && (
                    <button
                      onClick={() => setShowAddExample(true)}
                      className="px-3 py-1 text-sm rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition flex items-center gap-1"
                    >
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className="h-4 w-4">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                      </svg>
                      新增例句
                    </button>
                  )}
                </div>
                
                <div className="space-y-3">
                  {allExamples.map((example, idx) => renderExampleCard(example, idx))}
                  
                  {showAddExample && (
                    <div className="rounded-2xl border-2 border-indigo-300 bg-indigo-50/50 px-4 py-4 space-y-3">
                      <div className="flex items-center justify-between mb-2">
                        <div className="text-sm font-semibold text-indigo-700">新增自訂例句</div>
                        <button
                          onClick={() => setShowAddExample(false)}
                          className="text-gray-500 hover:text-gray-700"
                        >
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className="h-5 w-5">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                          </svg>
                        </button>
                      </div>
                      <div>
                        <label className="block text-sm text-gray-700 mb-1">英文例句</label>
                        <input
                          type="text"
                          value={newExampleEn}
                          onChange={(e) => setNewExampleEn(e.target.value)}
                          placeholder="輸入英文例句..."
                          className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        />
                      </div>
                      <div>
                        <label className="block text-sm text-gray-700 mb-1">中文翻譯</label>
                        <input
                          type="text"
                          value={newExampleZh}
                          onChange={(e) => setNewExampleZh(e.target.value)}
                          placeholder="輸入中文翻譯..."
                          className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        />
                      </div>
                      <div className="flex gap-2 justify-end">
                        <button
                          onClick={() => setShowAddExample(false)}
                          className="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition"
                        >
                          取消
                        </button>
                        <button
                          onClick={handleAddExample}
                          className="px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition"
                        >
                          儲存
                        </button>
                      </div>
                    </div>
                  )}
                  
                  {allExamples.length === 0 && (
                    <div className="text-gray-500 text-sm py-4 text-center">
                      目前沒有例句，點擊「新增例句」來新增第一個例句
                    </div>
                  )}
                </div>
              </div>
            </div>

            <div className="space-y-4">
              <section className="rounded-2xl border border-gray-200 bg-white/80 p-5">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* 左欄：詞性 */}
                  <div>
                    <h2 className="text-lg font-semibold text-gray-800 mb-3">詞性</h2>
                    <div className="text-base text-gray-700">
                      {String(word.word_forms || word['詞性變化'] || '').split('\n').map((line, idx, arr) => (
                        <React.Fragment key={idx}>
                          {line}
                          {idx < arr.length - 1 && <br />}
                        </React.Fragment>
                      ))}
                    </div>
                  </div>
                  
                  {/* 右欄：片語 */}
                  {Array.isArray(word.phrases) && word.phrases.length > 0 && (
                    <div>
                      <h2 className="text-lg font-semibold text-gray-800 mb-3">片語</h2>
                      <div className="flex flex-wrap gap-2">
                        {word.phrases.map((phrase, idx) => (
                          <span key={`phrase-${idx}`} className="px-4 py-2 text-base font-semibold rounded-lg bg-purple-100 text-purple-700 border border-purple-300 shadow-sm">{phrase}</span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </section>

              {hasSynonymBlock ? (
                <section className="rounded-2xl border border-gray-200 bg-white/80 p-5">
                  <h2 className="text-lg font-semibold text-gray-800 mb-3">同義／反義／易混淆</h2>
                  <div className="grid gap-4 md:grid-cols-3 text-base text-gray-700">
                    {synonyms.length ? (
                      <div>
                        <div className="text-sm font-semibold text-gray-500 mb-1">同義字</div>
                        {renderTagPill(synonyms, 'bg-blue-50 text-blue-600 text-base')}
                      </div>
                    ) : null}
                    {antonyms.length ? (
                      <div>
                        <div className="text-sm font-semibold text-gray-500 mb-1">反義字</div>
                        {renderTagPill(antonyms, 'bg-rose-50 text-rose-600 text-base')}
                      </div>
                    ) : null}
                    {confusables.length ? (
                      <div>
                        <div className="text-sm font-semibold text-gray-500 mb-1">易混淆字</div>
                        {renderTagPill(confusables, 'bg-amber-50 text-amber-600 text-base')}
                      </div>
                    ) : null}
                  </div>
                </section>
              ) : null}

              {hasAffixInfo ? (
                <section className="rounded-2xl border border-gray-200 bg-white/80">
                  <details open>
                    <summary className="cursor-pointer list-none px-5 py-4 text-lg font-semibold text-gray-800 flex items-center gap-2">
                      {(() => {
                        const availableItems = [];
                        if (affixInfo.prefix) availableItems.push('字首');
                        if (affixInfo.suffix) availableItems.push('字尾');
                        if (affixInfo.root) availableItems.push('字根');
                        return availableItems.join('｜') || '字首｜字尾｜字根';
                      })()}
                      <span className="inline-flex h-5 w-5 items-center justify-center rounded-full border border-gray-300 text-gray-500 text-xs"></span>
                    </summary>
                    <div className="px-5 pb-5">
                      <div className="text-base text-gray-700">
                        <div className="mb-2 text-gray-900">{(() => {
                          const availableItems = [];
                          if (affixInfo.prefix) availableItems.push('字首');
                          if (affixInfo.suffix) availableItems.push('字尾');
                          if (affixInfo.root) availableItems.push('字根');
                          return availableItems.join('｜') || '字首｜字尾｜字根';
                        })()}</div>
                        <div className="grid gap-4 md:grid-cols-2">
                          {affixInfo.prefix && (
                            <div>
                              <div className="text-xs text-gray-500">字首</div>
                              <div className="mt-1 text-gray-900">{affixInfo.prefix}</div>
                            </div>
                          )}
                          {affixInfo.suffix && (
                            <div>
                              <div className="text-xs text-gray-500">字尾</div>
                              <div className="mt-1 text-gray-900">{affixInfo.suffix}</div>
                            </div>
                          )}
                          {affixInfo.root && (
                            <div className="md:col-span-2">
                              <div className="text-xs text-gray-500">字根</div>
                              <div className="mt-1 text-gray-900">{affixInfo.root}</div>
                            </div>
                          )}
                          <div className="md:col-span-2">
                            <div className="text-xs text-gray-500">意思</div>
                            <div className="mt-1 text-gray-900 whitespace-pre-wrap">{affixInfo.meaning || '—'}</div>
                          </div>
                          <div className="md:col-span-2">
                            <div className="text-xs text-gray-500">例子</div>
                            <div className="mt-1 text-gray-900 whitespace-pre-wrap">{affixInfo.example || '—'}</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </details>
                </section>
              ) : null}
            </div>

            <div className="rounded-2xl border border-gray-200 bg-white/80">
              <details>
                <summary className="cursor-pointer list-none px-4 py-3 text-lg font-semibold text-gray-800 flex items-center gap-2">
                  匯出內容
                  <span className="inline-flex h-5 w-5 items-center justify-center rounded-full border border-gray-300 text-gray-500 text-xs"></span>
                </summary>
                <div className="px-4 pb-4 flex flex-wrap gap-4 text-sm text-gray-700">
                {[
                  { key: 'pos', label: '詞性區塊' },
                  { key: 'relations', label: '同義／反義／易混淆' },
                  { key: 'affix', label: '字根字首字尾' }
                ].map((opt) => (
                  <label key={opt.key} className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={!!exportSections[opt.key]}
                      onChange={() => toggleExportSection(opt.key)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <span>{opt.label}</span>
                  </label>
                ))}
                  <div className="flex justify-end gap-2 pt-2 w-full">
                    <Button variant="ghost" onClick={handleOutput}>匯出 Markdown</Button>
                  </div>
                </div>
              </details>
            </div>
            {mdStatus && <div className="text-sm text-gray-500 text-right">{mdStatus}</div>}
            {showMdPreview && (
              <div className="mt-3">
                <textarea value={mdPreview} readOnly className="w-full h-32 md:h-40 px-3 py-2 rounded-lg border border-gray-300 text-xs font-mono bg-white/80" />
                <div className="mt-1 text-xs text-gray-400 text-right">選取並複製後即可貼到 Google 文件／投影片。</div>
              </div>
            )}
          </div>
        );
      };

      const escapeForRegex = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const makeCloze = (sentence, answer) => {
        const esc = escapeForRegex(answer);
        const rx = new RegExp(`(^|[^A-Za-z])(${esc})(?=[^A-Za-z]|$)`, 'i');
        return String(sentence).replace(rx, (m) => m.replace(new RegExp(esc, 'i'), '_____ '));
      };

      const FavoritesPage = ({ favoritesApi, data }) => {
        const items = data.filter((w) => favoritesApi.favorites.includes(w.id));
        return (
          <div>
            <div className="flex items-center justify-between">
              <h1 className="text-2xl font-bold">重點訓練（{items.length}）</h1>
              <div className="flex gap-2">
                <a href="#/quiz?source=favorites"><Button>開始測驗</Button></a>
                {items.length>0 && <Button variant="ghost" onClick={favoritesApi.clear}>全部清除</Button>}
              </div>
            </div>
            {items.length === 0 ? (
              <p className="text-gray-600 mt-3">尚未加入任何單字。前往單字頁按「加入最愛」。</p>
            ) : (
              <div className="grid grid-cols-2 md:grid-cols-3 gap-3 mt-4">
                {items.map((w) => (
                  <div key={w.id} className="rounded-xl border p-3">
                    <a className="font-semibold hover:underline" href={`#/word/${w.id}`}>{w.english_word}</a>
                    <div className="text-xs text-gray-500 mb-2">{(w.posTags||[]).join(', ')}</div>
                    <Button variant="ghost" onClick={()=>favoritesApi.remove(w.id)}>移除</Button>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      };

      // 完成畫面組件
      const QuizCompletionScreen = ({ type, totalQuestions, correct, wrong, learning, wrongWords, learningWords, favoritesApi, onRestart, data }) => {
        const [showWrongList, setShowWrongList] = useState(true);
        const [showLearningList, setShowLearningList] = useState(true);
        const [addedWrong, setAddedWrong] = useState(false);
        const [addedLearning, setAddedLearning] = useState(false);
        
        const correctRate = totalQuestions > 0 ? Math.round((correct / totalQuestions) * 100 * 10) / 10 : 0;
        
        const handleAddWrongToFavorites = () => {
          if (wrongWords.length === 0) return;
          wrongWords.forEach(w => {
            if (w.wordId && !favoritesApi.favorites.includes(w.wordId)) {
              favoritesApi.toggle(w.wordId);
            }
          });
          setAddedWrong(true);
        };
        
        const handleAddLearningToFavorites = () => {
          if (learningWords.length === 0) return;
          learningWords.forEach(w => {
            if (w.wordId && !favoritesApi.favorites.includes(w.wordId)) {
              favoritesApi.toggle(w.wordId);
            }
          });
          setAddedLearning(true);
        };
        
        return (
          <div className="text-center py-8 bg-gradient-to-br from-green-50 to-white rounded-2xl border-2 border-green-200">
            <div className="text-4xl mb-4">🎉</div>
            <h2 className="text-2xl font-bold text-gray-800 mb-2">
              {type === 'flashcard' ? '閃卡複習完成！' : '測驗完成！'}
            </h2>
            
            {/* 成績統計 */}
            {type === 'flashcard' ? (
              <div className="mb-6">
                <div className="flex justify-center gap-8 text-lg">
                  <div>
                    <span className="text-green-600 font-semibold text-xl">✓ 你已學會：{correct} 個</span>
                  </div>
                  {learning > 0 && (
                    <div>
                      <span className="text-orange-600 font-semibold text-xl">📖 還不熟：{learning} 個</span>
                    </div>
                  )}
                </div>
              </div>
            ) : (
              <div className="mb-6 space-y-2">
                <p className="text-lg text-gray-700">
                  總題數：<span className="font-semibold">{totalQuestions}</span> 題
                </p>
                <div className="flex justify-center gap-6 text-base">
                  <div>
                    <span className="text-green-600 font-semibold">正確：{correct} 題</span>
                    <span className="text-gray-500 ml-2">({correctRate}%)</span>
                  </div>
                  <div>
                    <span className="text-red-600 font-semibold">錯誤：{wrong} 題</span>
                    <span className="text-gray-500 ml-2">({totalQuestions > 0 ? Math.round((wrong / totalQuestions) * 100 * 10) / 10 : 0}%)</span>
                  </div>
                </div>
              </div>
            )}
            
            {/* 錯誤題目列表 */}
            {wrongWords.length > 0 && (
              <div className="mb-6 text-left max-w-3xl mx-auto">
                <button
                  onClick={() => setShowWrongList(!showWrongList)}
                  className="w-full flex items-center justify-between p-3 bg-red-50 rounded-lg border border-red-200 hover:bg-red-100 transition"
                >
                  <span className="font-semibold text-red-700">
                    {showWrongList ? '▼' : '▶'} 錯誤題目 ({wrongWords.length}題)
                  </span>
                </button>
                {showWrongList && (
                  <div className="mt-2 space-y-3">
                    {wrongWords.map((w, idx) => (
                      <div key={idx} className="p-4 bg-white rounded-lg border border-red-200">
                        <div className="font-semibold text-gray-800 mb-2">
                          {idx + 1}. {w.wordId && data ? (
                            <a 
                              href={`#/word/${w.wordId}`}
                              onClick={() => {
                                // 確保保存正確的錯題測驗路徑
                                const currentHash = window.location.hash || '#/quiz';
                                const returnPath = currentHash.includes('source=wrong-words') 
                                  ? currentHash 
                                  : '#/quiz?source=wrong-words&type=multiple-choice';
                                sessionStorage.setItem('quiz_return_path', JSON.stringify({
                                  path: returnPath,
                                  timestamp: Date.now()
                                }));
                              }}
                              className="text-indigo-600 hover:underline"
                            >
                              {w.word}
                            </a>
                          ) : w.word}
                        </div>
                        {w.question && (
                          <div className="text-sm text-gray-600 mb-1">
                            題目：{w.question}
                          </div>
                        )}
                        <div className="flex items-center gap-4 text-sm">
                          <div>
                            <span className="text-gray-500">正確答案：</span>
                            <span className="text-green-600 font-semibold ml-1">{w.correctAnswer}</span>
                          </div>
                          {w.userAnswer && (
                            <div>
                              <span className="text-gray-500">你的答案：</span>
                              <span className="text-red-600 font-semibold ml-1">{w.userAnswer}</span>
                            </div>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
            
            {/* 學習中單字列表（僅閃卡） */}
            {learningWords.length > 0 && (
              <div className="mb-6 text-left max-w-3xl mx-auto">
                <button
                  onClick={() => setShowLearningList(!showLearningList)}
                  className="w-full flex items-center justify-between p-3 bg-orange-50 rounded-lg border border-orange-200 hover:bg-orange-100 transition"
                >
                  <span className="font-semibold text-orange-700">
                    {showLearningList ? '▼' : '▶'} 學習中單字 ({learningWords.length}題)
                  </span>
                </button>
                {showLearningList && (
                  <div className="mt-2 space-y-3">
                    {learningWords.map((w, idx) => (
                      <div key={idx} className="p-4 bg-white rounded-lg border border-orange-200">
                        <div className="font-semibold text-gray-800 mb-2">
                          {idx + 1}. {w.word}
                        </div>
                        {w.wordId && data && (
                          <div className="mt-2">
                            <a 
                              href={`#/word/${w.wordId}`}
                              onClick={() => {
                                // 確保保存正確的測驗路徑
                                const currentHash = window.location.hash || '#/quiz';
                                const returnPath = currentHash.includes('source=') 
                                  ? currentHash 
                                  : '#/quiz';
                                sessionStorage.setItem('quiz_return_path', JSON.stringify({
                                  path: returnPath,
                                  timestamp: Date.now()
                                }));
                              }}
                              className="text-xs text-indigo-600 hover:underline"
                            >
                              查看單字詳情 →
                            </a>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
            
            {/* 操作按鈕 */}
            <div className="space-y-3">
              {wrongWords.length > 0 && (
                <div>
                  <Button
                    variant="primary"
                    onClick={handleAddWrongToFavorites}
                    disabled={addedWrong}
                    className="mb-2"
                  >
                    {addedWrong ? `已加入 ${wrongWords.length} 個單字到重點訓練 ✓` : `將錯題加入重點訓練 (${wrongWords.length}個)`}
                  </Button>
                </div>
              )}
              
              {learningWords.length > 0 && (
                <div>
                  <Button
                    variant="primary"
                    onClick={handleAddLearningToFavorites}
                    disabled={addedLearning}
                    className="mb-2"
                  >
                    {addedLearning ? `已加入 ${learningWords.length} 個單字到重點訓練 ✓` : `將學習中的單字加入重點訓練 (${learningWords.length}個)`}
                  </Button>
                </div>
              )}
              
              <div className="flex gap-3 justify-center">
                <Button variant="ghost" onClick={onRestart}>
                  重新開始測驗
                </Button>
              </div>
            </div>
          </div>
        );
      };

      // 選擇題測驗組件
      const MultipleChoiceQuiz = ({ pool, favoritesApi, quizHistoryApi, onRestart, data }) => {
        // 檢查是否應該直接顯示完成畫面
        const shouldShowCompletion = (() => {
          try {
            const completedState = JSON.parse(sessionStorage.getItem('quiz_completed_state') || 'null');
            if (completedState && completedState.type === 'multiple-choice' && completedState.timestamp && Date.now() - completedState.timestamp < 3600000) {
              return true;
            }
          } catch {}
          return false;
        })();
        
        const validPool = useMemo(() => 
          pool.filter(w => w.example_sentence && w.example_sentence.trim()), 
          [pool]
        );

        // 隨機打亂題目順序
        const shuffledPool = useMemo(() => {
          return [...validPool].sort(() => Math.random() - 0.5);
        }, [validPool]);

        // 為每道題目預先分配正確答案位置（0=A, 1=B, 2=C, 3=D），確保平均分布
        const correctAnswerPositions = useMemo(() => {
          const total = shuffledPool.length;
          if (total === 0) return [];
          
          // 計算每個位置應該有幾題
          const baseCount = Math.floor(total / 4);
          const remainder = total % 4;
          
          // 建立位置陣列：先每個位置分配 baseCount 題，剩餘的題目依序分配
          const positions = [];
          for (let i = 0; i < 4; i++) {
            const count = baseCount + (i < remainder ? 1 : 0);
            for (let j = 0; j < count; j++) {
              positions.push(i);
            }
          }
          
          // 打亂位置順序，避免固定模式
          return positions.sort(() => Math.random() - 0.5);
        }, [shuffledPool.length]);

        const [idx, setIdx] = useState(0);
        const [score, setScore] = useState(0);
        const [selectedAnswer, setSelectedAnswer] = useState(null);
        const [showResult, setShowResult] = useState(false);
        const [answers, setAnswers] = useState([]); // 記錄所有答案
        const [startTime] = useState(() => Date.now()); // 記錄開始時間
        const [isFinished, setIsFinished] = useState(shouldShowCompletion);

        const question = useMemo(() => {
          if (shuffledPool.length === 0 || idx >= shuffledPool.length) return null;
          
          const currentWord = shuffledPool[idx];
          const correctAnswer = currentWord.english_word;
          const correctPosition = correctAnswerPositions[idx];
          
          const sameTheme = shuffledPool.filter(w => 
            w.theme === currentWord.theme && 
            w.english_word !== correctAnswer
          );
          
          const distractors = [];
          const shuffled = [...sameTheme].sort(() => Math.random() - 0.5);
          for (let i = 0; i < Math.min(3, shuffled.length); i++) {
            distractors.push(shuffled[i].english_word);
          }
          
          while (distractors.length < 3 && distractors.length < shuffledPool.length - 1) {
            const random = shuffledPool[Math.floor(Math.random() * shuffledPool.length)];
            if (random.english_word !== correctAnswer && !distractors.includes(random.english_word)) {
              distractors.push(random.english_word);
            }
          }
          
          // 建立選項陣列，先補齊到4個干擾選項
          const allDistractors = [...distractors];
          while (allDistractors.length < 4) {
            const random = shuffledPool[Math.floor(Math.random() * shuffledPool.length)];
            if (random.english_word !== correctAnswer && !allDistractors.includes(random.english_word)) {
              allDistractors.push(random.english_word);
            }
          }
          
          // 建立最終選項陣列，將正確答案放在預先分配的位置
          const finalOptions = [...allDistractors.slice(0, 4)];
          finalOptions[correctPosition] = correctAnswer;
          
          // 使用 makeCloze 將答案從例句中挖空
          const clozedSentence = makeCloze(currentWord.example_sentence, correctAnswer);
          
          return {
            word: currentWord,
            sentence: clozedSentence,
            translation: currentWord.example_translation,
            correctAnswer,
            options: finalOptions
          };
        }, [shuffledPool, idx, correctAnswerPositions]);

        const handleSelect = (option) => {
          if (showResult) return;
          setSelectedAnswer(option);
        };

        const handleSubmit = () => {
          if (!selectedAnswer) return;
          setShowResult(true);
          const isCorrect = selectedAnswer === question.correctAnswer;
          if (isCorrect) {
            setScore(s => s + 1);
          }
          // 記錄答案
          setAnswers(prev => [...prev, {
            wordId: question.word.id,
            word: question.word.english_word,
            correctAnswer: question.correctAnswer,
            userAnswer: selectedAnswer,
            isCorrect,
            question: question.sentence,
            translation: question.translation
          }]);
        };

        const handleNext = () => {
          if (idx < shuffledPool.length - 1) {
            setIdx(i => i + 1);
            setSelectedAnswer(null);
            setShowResult(false);
          } else {
            // 完成測驗
            const endTime = Date.now();
            const duration = Math.floor((endTime - startTime) / 1000);
            const wrongWords = answers.filter(a => !a.isCorrect);
            const correctWords = answers.filter(a => a.isCorrect);
            
            // 儲存記錄
            quizHistoryApi.add({
              type: 'multiple-choice',
              totalQuestions: shuffledPool.length,
              correct: score,
              wrong: wrongWords.length,
              learning: 0,
              wrongWords: wrongWords.map(a => ({
                wordId: a.wordId,
                word: a.word,
                correctAnswer: a.correctAnswer,
                userAnswer: a.userAnswer,
                question: a.question
              })),
              correctWords: correctWords.map(a => a.wordId),
              duration,
              mode: null
            });
            
            // 儲存完成狀態到 sessionStorage，以便從單字詳情返回時可以顯示完成畫面
            sessionStorage.setItem('quiz_completed_state', JSON.stringify({
              type: 'multiple-choice',
              timestamp: Date.now()
            }));
            
            setIsFinished(true);
          }
        };

        // 顯示完成畫面（優先檢查，避免 pool 為空時無法顯示完成畫面）
        if (isFinished) {
          // 從最新的歷史記錄中取得資料（參考閃卡的做法）
          const history = quizHistoryApi.getAll();
          const latest = history[0];
          
          if (latest && latest.type === 'multiple-choice') {
            return (
              <QuizCompletionScreen
                type="multiple-choice"
                totalQuestions={latest.totalQuestions}
                correct={latest.correct}
                wrong={latest.wrong}
                learning={0}
                wrongWords={latest.wrongWords || []}
                learningWords={[]}
                favoritesApi={favoritesApi}
                onRestart={onRestart}
                data={data}
              />
            );
          }
          
          // 如果沒有記錄，使用當前狀態（fallback）
          const wrongWords = answers.filter(a => !a.isCorrect);
          const correctCount = score;
          const wrongCount = wrongWords.length;
          const totalCount = shuffledPool.length;
          const correctRate = totalCount > 0 ? Math.round((correctCount / totalCount) * 100 * 10) / 10 : 0;
          const duration = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          
          return (
            <QuizCompletionScreen
              type="multiple-choice"
              totalQuestions={totalCount}
              correct={correctCount}
              wrong={wrongCount}
              learning={0}
              wrongWords={wrongWords}
              learningWords={[]}
              favoritesApi={favoritesApi}
              onRestart={onRestart}
              data={data}
            />
          );
        }

        // 檢查是否有可用的題目（在完成畫面檢查之後）
        if (shuffledPool.length === 0) {
          return (
            <div className="text-center py-8 bg-gray-50 rounded-2xl">
              <p className="text-gray-600">沒有可用的題目（需要有例句的單字）</p>
            </div>
          );
        }

        if (!question) return null;

        return (
          <div>
            <div className="mb-4 flex items-center justify-between">
              <div className="text-sm text-gray-600">
                第 {idx + 1} 題 / {shuffledPool.length} 題
              </div>
              <div className="text-lg font-semibold text-indigo-600">
                得分：{score} / {idx + (showResult ? 1 : 0)}
              </div>
            </div>

            <div className="rounded-2xl border border-indigo-200 bg-white p-6 shadow-sm">
              {/* 刪除「⭐ 人工審核例句」標示 */}
              
              {/* 提示文字移到例句上方 */}
              <p className="text-sm font-medium text-gray-700 mb-3">
                請選出句中最適合的單字：
              </p>
              
              {/* 顯示挖空的句子 */}
              <p className="text-lg mb-6 leading-relaxed">
                {question.sentence}
              </p>

              {/* 答題前不顯示中文翻譯 */}
              {showResult && question.translation && (
                <p className="text-sm text-gray-500 mb-6 italic">
                  {question.translation}
                </p>
              )}

              <div className="mb-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {question.options.map((option, i) => {
                    const isSelected = selectedAnswer === option;
                    const isCorrect = option === question.correctAnswer;
                    const showCorrect = showResult && isCorrect;
                    const showWrong = showResult && isSelected && !isCorrect;
                    
                    let bgColor = 'bg-white border-gray-300';
                    if (showCorrect) bgColor = 'bg-green-100 border-green-500';
                    else if (showWrong) bgColor = 'bg-red-100 border-red-500';
                    else if (isSelected) bgColor = 'bg-indigo-50 border-indigo-500';

                    return (
                      <button
                        key={i}
                        onClick={() => handleSelect(option)}
                        disabled={showResult}
                        className={`${bgColor} border-2 rounded-xl p-4 text-left transition hover:shadow-md disabled:cursor-not-allowed`}
                      >
                        <span className="font-medium">{String.fromCharCode(65 + i)}.</span> {option}
                        {showCorrect && <span className="ml-2">✓</span>}
                        {showWrong && <span className="ml-2">✗</span>}
                      </button>
                    );
                  })}
                </div>
              </div>

              {showResult && (
                <div className={`p-4 rounded-xl mb-4 ${
                  selectedAnswer === question.correctAnswer 
                    ? 'bg-green-50 border border-green-200' 
                    : 'bg-red-50 border border-red-200'
                }`}>
                  <p className="font-medium mb-2">
                    {selectedAnswer === question.correctAnswer ? '✓ 答對了！' : '✗ 答錯了'}
                  </p>
                  <p className="text-sm">
                    正確答案：<span className="font-semibold">{question.correctAnswer}</span>
                  </p>
                  {question.word.chinese_definition && (
                    <p className="text-sm text-gray-600">
                      中文：{question.word.chinese_definition}
                    </p>
                  )}
                </div>
              )}

              <div className="flex gap-3">
                {!showResult ? (
                  <Button onClick={handleSubmit} disabled={!selectedAnswer}>
                    提交答案
                  </Button>
                ) : (
                  <>
                    <Button onClick={handleNext}>
                      下一題
                    </Button>
                    {/* 答題後才顯示發音按鈕 */}
                    <button
                      onClick={() => speak(question.correctAnswer)}
                      className="px-4 py-2 rounded-xl border border-gray-300 hover:bg-gray-50 transition"
                      title="發音"
                    >
                      🔊 聽發音
                    </button>
                  </>
                )}
              </div>
            </div>
          </div>
        );
      };

      // 閃卡組件
      const FlashcardQuiz = ({ pool, favoritesApi, quizHistoryApi, onRestart, data }) => {
        // 檢查是否應該直接顯示完成畫面
        const shouldShowCompletion = (() => {
          try {
            const completedState = JSON.parse(sessionStorage.getItem('quiz_completed_state') || 'null');
            if (completedState && completedState.timestamp && Date.now() - completedState.timestamp < 3600000) {
              return true;
            }
          } catch {}
          return false;
        })();
        
        // 初始化時洗牌一次，之後不再改變
        const [shuffledPool] = useState(() => {
          const shuffled = [...pool];
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
          }
          console.log('閃卡初始化完成，共', shuffled.length, '張');
          return shuffled;
        });

        const [idx, setIdx] = useState(0);
        const [mode, setMode] = useState('en-to-zh');
        const [flipped, setFlipped] = useState(false);
        const [known, setKnown] = useState(0);
        const [learning, setLearning] = useState(0);
        const [answers, setAnswers] = useState([]);
        const [startTime] = useState(() => Date.now());
        const [isFinished, setIsFinished] = useState(shouldShowCompletion);

        // 檢查是否已完成所有閃卡
        const isFinishedCheck = idx >= shuffledPool.length || isFinished;

        const currentCard = isFinishedCheck ? null : shuffledPool[idx];

        const handleFlip = () => {
          if (!isFinishedCheck) {
            console.log('翻卡');
            setFlipped(f => !f);
          }
        };

        const handleNext = (isKnown) => {
          console.log('handleNext 被調用', { idx, shuffledPoolLength: shuffledPool.length, isKnown });
          const currentWord = shuffledPool[idx];
          if (!currentWord) {
            console.error('currentWord 為空', { idx, shuffledPoolLength: shuffledPool.length });
            return;
          }
          const status = isKnown ? 'correct' : 'learning'; // 「還不熟」視為「學習中」
          
          // 記錄答案
          const currentAnswer = {
            wordId: currentWord.id,
            word: currentWord.english_word,
            status,
            isCorrect: isKnown
          };
          
          setAnswers(prev => [...prev, currentAnswer]);
          
          // 先更新計數
          const newKnown = isKnown ? known + 1 : known;
          const newLearning = isKnown ? learning : learning + 1;
          
          if (idx < shuffledPool.length - 1) {
            const nextIdx = idx + 1;
            console.log('切換到下一張', { currentIdx: idx, nextIdx, shuffledPoolLength: shuffledPool.length });
            // 使用函數式更新確保使用最新的 idx
            setIdx(prevIdx => {
              const newIdx = prevIdx + 1;
              console.log('setIdx 被調用', { prevIdx, newIdx });
              return newIdx;
            });
            setFlipped(false);
            // 更新計數狀態
            setKnown(newKnown);
            setLearning(newLearning);
          } else {
            // 完成測驗 - 最後一張卡的答案已經記錄了
            const endTime = Date.now();
            const duration = Math.floor((endTime - startTime) / 1000);
            const allAnswers = [...answers, currentAnswer]; // 包含最後一張卡的答案
            const wrongWords = []; // 閃卡沒有「錯誤」，只有「學習中」
            const learningWords = allAnswers.filter(a => a.status === 'learning');
            const correctWords = allAnswers.filter(a => a.isCorrect);
            
            // 更新計數狀態
            setKnown(newKnown);
            setLearning(newLearning);
            
            // 儲存記錄
            quizHistoryApi.add({
              type: 'flashcard',
              totalQuestions: shuffledPool.length,
              correct: newKnown,
              wrong: 0,
              learning: newLearning,
              wrongWords: [],
              learningWords: learningWords.map(a => ({
                wordId: a.wordId,
                word: a.word
              })),
              correctWords: correctWords.map(a => a.wordId),
              duration,
              mode
            });
            
            // 儲存完成狀態到 sessionStorage，以便從單字詳情返回時可以顯示完成畫面
            sessionStorage.setItem('quiz_completed_state', JSON.stringify({
              type: 'flashcard',
              timestamp: Date.now()
            }));
            
            setIsFinished(true);
          }
        };

        const toggleMode = () => {
          if (!isFinished) {
            setMode(m => m === 'en-to-zh' ? 'zh-to-en' : 'en-to-zh');
            setFlipped(false);
          }
        };

        if (shuffledPool.length === 0) {
          return (
            <div className="text-center py-8 bg-gray-50 rounded-2xl">
              <p className="text-gray-600">沒有可用的閃卡</p>
            </div>
          );
        }

        // 顯示完成畫面
        if (isFinished) {
          // 從最新的歷史記錄中取得資料
          const history = quizHistoryApi.getAll();
          const latest = history[0];
          
          if (latest && latest.type === 'flashcard') {
            return (
              <QuizCompletionScreen
                type="flashcard"
                totalQuestions={latest.totalQuestions}
                correct={latest.correct}
                wrong={0}
                learning={latest.learning}
                wrongWords={[]}
                learningWords={latest.learningWords || []}
                favoritesApi={favoritesApi}
                onRestart={onRestart}
                data={data}
              />
            );
          }
          
          // 如果沒有記錄，使用當前狀態
          const allAnswers = answers;
          const learningWords = allAnswers.filter(a => a.status === 'learning');
          const correctCount = known;
          const learningCount = learning;
          const totalCount = shuffledPool.length;
          
          return (
            <QuizCompletionScreen
              type="flashcard"
              totalQuestions={totalCount}
              correct={correctCount}
              wrong={0}
              learning={learningCount}
              wrongWords={[]}
              learningWords={learningWords}
              favoritesApi={favoritesApi}
              onRestart={onRestart}
              data={data}
            />
          );
        }

        const frontText = mode === 'en-to-zh' 
          ? currentCard.english_word 
          : currentCard.chinese_definition || '(無中文翻譯)';
        
        const backText = mode === 'en-to-zh' 
          ? currentCard.chinese_definition || '(無中文翻譯)'
          : currentCard.english_word;

        return (
          <div>
            <div className="mb-4 flex items-center justify-between flex-wrap gap-2">
              <div className="text-sm text-gray-600">
                第 {idx + 1} 張 / {shuffledPool.length} 張
                <span className="text-xs text-gray-400 ml-2">
                  (idx: {idx}, pool: {pool.length}, shuffled: {shuffledPool.length}, flipped: {flipped ? 'true' : 'false'})
                </span>
              </div>
              <div className="flex gap-4 text-sm">
                <span className="text-green-600">✓ 熟悉：{known}</span>
                <span className="text-orange-600">📖 學習中：{learning}</span>
              </div>
              <Button variant="ghost" onClick={toggleMode} className="text-sm">
                {mode === 'en-to-zh' ? '英→中' : '中→英'} (切換)
              </Button>
            </div>

            <div 
              className={`flashcard ${flipped ? 'flipped' : ''} cursor-pointer`}
              onClick={handleFlip}
            >
              <div className="flashcard-inner h-[300px] md:h-[400px]">
                <div className="flashcard-front">
                  <div className="rounded-2xl border-2 border-indigo-300 bg-gradient-to-br from-indigo-50 to-white p-8 shadow-lg h-full flex flex-col items-center justify-center">
                    <div className="text-xs text-gray-500 mb-4">點擊卡片翻面</div>
                    <div className="flex items-center justify-center gap-2 mb-4">
                      <div className="text-3xl md:text-4xl font-bold text-center">
                        {frontText}
                      </div>
                      {mode === 'en-to-zh' && (
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            speak(frontText);
                          }}
                          className="flex-shrink-0 h-6 w-6 rounded-full border border-indigo-300 bg-white text-indigo-600 hover:bg-indigo-50 transition flex items-center justify-center"
                          title="播放發音"
                        >
                          <svg viewBox="0 0 24 24" fill="currentColor" className="h-3 w-3">
                            <path d="M4 9.25v5.5c0 .69.56 1.25 1.25 1.25H7l3.29 2.63c.83.66 2.04.07 2.04-1V6.62c0-1.07-1.21-1.66-2.04-1L7 8.25H5.25C4.56 8.25 4 8.81 4 9.25Zm11.21-2.46a.75.75 0 0 0-.97 1.14 4.5 4.5 0 0 1 0 7.14.75.75 0 0 0 .97 1.14 6 6 0 0 0 0-9.42Zm2.79-1.95a.75.75 0 0 0-.97 1.13 7.5 7.5 0 0 1 0 11.56.75.75 0 0 0 .97 1.13 9 9 0 0 0 0-13.82Z" />
                          </svg>
                        </button>
                      )}
                    </div>
                  </div>
                </div>

                <div className="flashcard-back">
                  <div className="rounded-2xl border-2 border-green-300 bg-gradient-to-br from-green-50 to-white p-8 shadow-lg h-full flex flex-col items-center justify-center">
                    <div className="text-xs text-gray-500 mb-4">答案</div>
                    <div className="flex items-center justify-center gap-2 mb-4">
                      <div className="text-3xl md:text-4xl font-bold text-center">
                        {backText}
                      </div>
                      {mode === 'zh-to-en' && (
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            speak(currentCard.english_word);
                          }}
                          className="flex-shrink-0 h-6 w-6 rounded-full border border-green-300 bg-white text-green-600 hover:bg-green-50 transition flex items-center justify-center"
                          title="播放發音"
                        >
                          <svg viewBox="0 0 24 24" fill="currentColor" className="h-3 w-3">
                            <path d="M4 9.25v5.5c0 .69.56 1.25 1.25 1.25H7l3.29 2.63c.83.66 2.04.07 2.04-1V6.62c0-1.07-1.21-1.66-2.04-1L7 8.25H5.25C4.56 8.25 4 8.81 4 9.25Zm11.21-2.46a.75.75 0 0 0-.97 1.14 4.5 4.5 0 0 1 0 7.14.75.75 0 0 0 .97 1.14 6 6 0 0 0 0-9.42Zm2.79-1.95a.75.75 0 0 0-.97 1.13 7.5 7.5 0 0 1 0 11.56.75.75 0 0 0 .97 1.13 9 9 0 0 0 0-13.82Z" />
                          </svg>
                        </button>
                      )}
                    </div>
                    {currentCard.example_sentence && (
                      <div className="mt-4 text-center max-w-md">
                        <div className="flex items-center justify-center gap-2 mb-2">
                          <p className="text-lg text-gray-600 italic leading-relaxed">{currentCard.example_sentence}</p>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              speak(currentCard.example_sentence);
                            }}
                            className="flex-shrink-0 h-6 w-6 rounded-full border border-green-300 bg-white text-green-600 hover:bg-green-50 transition flex items-center justify-center"
                            title="播放例句發音"
                          >
                            <svg viewBox="0 0 24 24" fill="currentColor" className="h-3 w-3">
                              <path d="M4 9.25v5.5c0 .69.56 1.25 1.25 1.25H7l3.29 2.63c.83.66 2.04.07 2.04-1V6.62c0-1.07-1.21-1.66-2.04-1L7 8.25H5.25C4.56 8.25 4 8.81 4 9.25Zm11.21-2.46a.75.75 0 0 0-.97 1.14 4.5 4.5 0 0 1 0 7.14.75.75 0 0 0 .97 1.14 6 6 0 0 0 0-9.42Zm2.79-1.95a.75.75 0 0 0-.97 1.13 7.5 7.5 0 0 1 0 11.56.75.75 0 0 0 .97 1.13 9 9 0 0 0 0-13.82Z" />
                            </svg>
                          </button>
                        </div>
                        {currentCard.example_translation && (
                          <p className="text-sm text-gray-500 italic">{currentCard.example_translation}</p>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>

            {flipped && (
              <div className="-mt-16 flex justify-center gap-4 relative z-10">
                <Button 
                  variant="danger" 
                  onClick={(e) => {
                    e.stopPropagation();
                    console.log('按鈕被點擊：還不熟', { idx, isFinished, shuffledPoolLength: shuffledPool.length });
                    handleNext(false);
                  }} 
                  disabled={isFinished}
                >
                  還不熟 😅
                </Button>
                <Button 
                  variant="success" 
                  onClick={(e) => {
                    e.stopPropagation();
                    console.log('按鈕被點擊：我記得了', { idx, isFinished, shuffledPoolLength: shuffledPool.length });
                    handleNext(true);
                  }} 
                  disabled={isFinished}
                >
                  我記得了 ✓
                </Button>
              </div>
            )}
          </div>
        );
      };

      const QuizPage = ({ favoritesApi, hash, data, push }) => {
        const quizHistoryApi = useQuizHistory();
        const params = useMemo(() => Object.fromEntries(new URLSearchParams((hash.split('?')[1]||''))), [hash]);
        const source = params.source || 'all';
        const quizType = params.type || 'multiple-choice';
        const restartKey = params._restart || '0'; // 用於強制重新渲染的 key
        
        // 讀取首頁的篩選條件
        const homeFilters = useMemo(() => {
          try {
            return JSON.parse(localStorage.getItem(LS.homeFilters) || '{}');
          } catch {
            return {};
          }
        }, []);

        const [currentSource, setCurrentSource] = useState(source);
        const [currentType, setCurrentType] = useState(quizType);

        // 當 URL 參數改變時，同步更新本地狀態
        useEffect(() => {
          setCurrentSource(source);
          setCurrentType(quizType);
        }, [source, quizType]);

        const pool = useMemo(() => {
          let filteredData = data;

          // 如果選擇「錯題測驗」，只使用錯題的單字（不應用其他篩選）
          if (currentSource === 'wrong-words') {
            try {
              const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
              if (wrongWordIds.length > 0) {
                const ids = new Set(wrongWordIds);
                filteredData = data.filter((w) => ids.has(w.id));
                // 錯題測驗也需要應用測驗類型的過濾（閃卡需要中文翻譯，選擇題需要例句）
                // 繼續執行後續的過濾邏輯，不直接返回
              } else {
                // 如果沒有錯題，返回空陣列
                return [];
              }
            } catch {
              // 如果讀取失敗，繼續使用其他邏輯
            }
          }

          // 如果選擇「重點訓練」，只使用收藏的單字
          if (currentSource === 'favorites') {
            const ids = new Set(favoritesApi.favorites);
            filteredData = data.filter((w) => ids.has(w.id));
            if (filteredData.length === 0) {
              filteredData = data;
            }
          }

          // 應用首頁的主題篩選（錯題測驗時不應用）
          if (currentSource !== 'wrong-words' && homeFilters.theme && homeFilters.theme !== 'all') {
            filteredData = filteredData.filter((w) => {
              if (wordHasTheme(w, homeFilters.theme)) return true;
              if (homeFilters.theme === 'highschool_climate') {
                const wordThemes = getWordThemes(w);
                return wordThemes.includes('氣候') || wordThemes.includes('climate');
              }
              return false;
            });
          }

          // 應用首頁的詞性篩選（錯題測驗時不應用）
          if (currentSource !== 'wrong-words' && homeFilters.pos && homeFilters.pos !== 'all') {
            filteredData = filteredData.filter(w => (w.posTags||[]).includes(homeFilters.pos));
          }

          // 應用首頁的 Level 篩選（錯題測驗時不應用）
          if (currentSource !== 'wrong-words' && homeFilters.levels && homeFilters.levels.length > 0) {
            filteredData = filteredData.filter(w => 
              homeFilters.levels.includes(String(w.level||'').trim())
            );
          }

          // 應用首頁的搜尋條件（錯題測驗時不應用）
          if (currentSource !== 'wrong-words' && homeFilters.q && homeFilters.q.trim()) {
            const searchTerm = homeFilters.q.trim().toLowerCase();
            filteredData = filteredData.filter(w => 
              w.english_word.toLowerCase().includes(searchTerm)
            );
          }

          // 如果是閃卡模式，過濾掉沒有中文翻譯的單字
          if (currentType === 'flashcard') {
            const beforeFilter = filteredData.length;
            filteredData = filteredData.filter(w => {
              const hasChinese = w.chinese_definition && w.chinese_definition.trim();
              return hasChinese;
            });
            // 調試：如果過濾後數量大幅減少，記錄一下
            if (beforeFilter > 0 && filteredData.length === 0) {
              console.warn('閃卡模式：過濾後沒有可用單字', {
                beforeFilter,
                currentSource,
                sample: filteredData.slice(0, 3).map(w => ({
                  word: w.english_word,
                  hasChinese: !!(w.chinese_definition && w.chinese_definition.trim())
                }))
              });
            }
          }

          // 如果是選擇題模式，過濾掉沒有例句的單字
          if (currentType === 'multiple-choice') {
            filteredData = filteredData.filter(w => 
              w.example_sentence && w.example_sentence.trim()
            );
          }

          return filteredData;
        }, [currentSource, currentType, favoritesApi.favorites, data, homeFilters]);

        // 顯示目前的篩選狀態
        const filterStatus = useMemo(() => {
          const filters = [];
          if (homeFilters.theme && homeFilters.theme !== 'all') {
            filters.push(THEME_LABEL[homeFilters.theme] || homeFilters.theme);
          }
          if (homeFilters.pos && homeFilters.pos !== 'all') {
            filters.push(POS_LABEL[homeFilters.pos] || homeFilters.pos);
          }
          if (homeFilters.levels && homeFilters.levels.length > 0) {
            filters.push(`Level ${homeFilters.levels.join(', ')}`);
          }
          if (homeFilters.q && homeFilters.q.trim()) {
            filters.push(`搜尋: ${homeFilters.q}`);
          }
          return filters.length > 0 ? filters.join(' / ') : '全部單字';
        }, [homeFilters]);

        return (
          <div className="max-w-4xl mx-auto">
            <div className="mb-6">
              <h1 className="text-2xl font-bold">
                實力驗收
              </h1>
              
              <p className="text-gray-600 mt-3 mb-4">
                {currentSource === 'wrong-words' 
                  ? `錯題測驗：${pool.length} 題` 
                  : pool.length > 0
                    ? `你已選擇練習 ${pool.length} 題` 
                    : '請先到首頁選擇測驗範圍'}
              </p>
              
              {/* 錯題測驗提示 */}
              {(() => {
                try {
                  const wrongWordIds = JSON.parse(localStorage.getItem(LS.wrongWordsQuiz) || '[]');
                  if (wrongWordIds.length > 0 && currentSource !== 'wrong-words') {
                    return (
                      <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                        <div className="flex items-center justify-between">
                          <span className="text-sm text-red-700">
                            🔴 你有 {wrongWordIds.length} 個錯題可以重新測驗
                          </span>
                          <a 
                            href="#/quiz?source=wrong-words&type=multiple-choice"
                            className="text-sm text-red-600 hover:underline font-medium"
                          >
                            前往錯題測驗 →
                          </a>
                        </div>
                      </div>
                    );
                  }
                } catch {
                  // 忽略錯誤
                }
                return null;
              })()}
              
              <div className="mb-4">
                <div className="flex gap-2">
                  <a href={`#/quiz?source=${currentSource}&type=multiple-choice`} className="flex-1">
                    <Button 
                      variant={currentType === 'multiple-choice' ? 'primary' : 'ghost'}
                      className="w-full"
                      onClick={() => setCurrentType('multiple-choice')}
                    >
                      📝 選擇題
                    </Button>
                  </a>
                  <a href={`#/quiz?source=${currentSource}&type=flashcard`} className="flex-1">
                    <Button 
                      variant={currentType === 'flashcard' ? 'primary' : 'ghost'}
                      className="w-full"
                      onClick={() => setCurrentType('flashcard')}
                    >
                      📇 閃卡
                    </Button>
                  </a>
                  <a href="#/quiz-history">
                    <Button variant="ghost">
                      📊 查看歷史記錄
                    </Button>
                  </a>
                </div>
              </div>
            </div>

            {(() => {
              const handleRestart = () => {
                // 清除完成狀態
                sessionStorage.removeItem('quiz_completed_state');
                sessionStorage.removeItem('quiz_return_path');
                
                // 如果是錯題測驗，清除錯題測驗狀態並回到上一次的篩選範圍
                if (currentSource === 'wrong-words') {
                  try {
                    localStorage.removeItem(LS.wrongWordsQuiz);
                  } catch {
                    // 忽略錯誤
                  }
                  // 導航到正常的測驗頁面（會使用 homeFilters）
                  push(`#/quiz?source=all&type=${currentType}`);
                } else {
                  // 保持當前的測驗範圍，添加時間戳參數以強制重新渲染
                  const timestamp = Date.now();
                  push(`#/quiz?source=${currentSource}&type=${currentType}&_restart=${timestamp}`);
                }
              };
              
              return currentType === 'flashcard' ? (
                <FlashcardQuiz 
                  key={`flashcard-${restartKey}`}
                  pool={pool} 
                  favoritesApi={favoritesApi}
                  quizHistoryApi={quizHistoryApi}
                  onRestart={handleRestart}
                  data={data}
                />
              ) : (
                <MultipleChoiceQuiz 
                  key={`multiple-choice-${restartKey}`}
                  pool={pool}
                  favoritesApi={favoritesApi}
                  quizHistoryApi={quizHistoryApi}
                  onRestart={handleRestart}
                  data={data}
                />
              );
            })()}
          </div>
        );
      };

      // 歷史記錄頁面
      const QuizHistoryPage = ({ quizHistoryApi, push, data }) => {
        const [expandedId, setExpandedId] = useState(null);
        const history = quizHistoryApi.getAll();
        
        const formatDate = (dateString) => {
          try {
            const date = new Date(dateString);
            return date.toLocaleString('zh-TW', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            });
          } catch {
            return dateString;
          }
        };
        
        const formatDuration = (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          if (mins > 0) {
            return `${mins}分${secs}秒`;
          }
          return `${secs}秒`;
        };
        
        const handleDelete = (id) => {
          if (confirm('確定要刪除這筆記錄嗎？')) {
            quizHistoryApi.remove(id);
          }
        };
        
        const handleClearAll = () => {
          if (confirm('確定要清除所有記錄嗎？此操作無法復原。')) {
            quizHistoryApi.clearAll();
          }
        };
        
        if (history.length === 0) {
          return (
            <div className="max-w-4xl mx-auto">
              <div className="mb-6">
                <Button variant="ghost" onClick={() => push('#/quiz')}>
                  ← 返回實力驗收
                </Button>
                <h1 className="text-2xl font-bold mt-4">測驗歷史記錄</h1>
              </div>
              <div className="text-center py-12 bg-gray-50 rounded-2xl">
                <p className="text-gray-600 mb-4">你目前沒有歷史紀錄</p>
                <Button variant="ghost" onClick={() => push('#/quiz')}>
                  返回實力驗收
                </Button>
              </div>
            </div>
          );
        }
        
        return (
          <div className="max-w-4xl mx-auto">
            <div className="mb-6">
              <Button variant="ghost" onClick={() => push('#/quiz')}>
                ← 返回實力驗收
              </Button>
              <div className="flex items-center justify-between mt-4">
                <h1 className="text-2xl font-bold">測驗歷史記錄</h1>
                <Button variant="danger" onClick={handleClearAll}>
                  清除所有記錄
                </Button>
              </div>
            </div>
            
            <div className="space-y-4">
              {history.map((record) => {
                const isExpanded = expandedId === record.id;
                const correctRate = record.totalQuestions > 0 
                  ? Math.round((record.correct / record.totalQuestions) * 100 * 10) / 10 
                  : 0;
                const typeLabel = record.type === 'flashcard' ? '閃卡測驗' : '選擇題測驗';
                
                return (
                  <div key={record.id} className="rounded-2xl border border-gray-200 bg-white p-5 shadow-sm">
                    <div className="flex items-center justify-between mb-3">
                      <div className="flex-1">
                        <div className="font-semibold text-gray-800 mb-1">
                          {formatDate(record.date)}
                        </div>
                        <div className="text-sm text-gray-600">
                          {typeLabel} | {record.correct}/{record.totalQuestions} 正確 ({correctRate}%)
                          {record.learning > 0 && ` | 學習中：${record.learning} 題`}
                        </div>
                      </div>
                      <div className="flex gap-2">
                        <Button 
                          variant="ghost" 
                          onClick={() => setExpandedId(isExpanded ? null : record.id)}
                        >
                          {isExpanded ? '收起詳情' : '查看詳情'}
                        </Button>
                        <Button variant="danger" onClick={() => handleDelete(record.id)}>
                          刪除
                        </Button>
                      </div>
                    </div>
                    
                    {isExpanded && (
                      <div className="mt-4 pt-4 border-t border-gray-200 space-y-4">
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                          <div>
                            <div className="text-gray-500">總題數</div>
                            <div className="font-semibold">{record.totalQuestions} 題</div>
                          </div>
                          <div>
                            <div className="text-gray-500">正確</div>
                            <div className="font-semibold text-green-600">{record.correct} 題</div>
                          </div>
                          <div>
                            <div className="text-gray-500">錯誤</div>
                            <div className="font-semibold text-red-600">{record.wrong} 題</div>
                          </div>
                          {record.learning > 0 && (
                            <div>
                              <div className="text-gray-500">學習中</div>
                              <div className="font-semibold text-orange-600">{record.learning} 題</div>
                            </div>
                          )}
                        </div>
                        
                        {record.duration && (
                          <div className="text-sm text-gray-600">
                            測驗時間：{formatDuration(record.duration)}
                          </div>
                        )}
                        
                        {record.wrongWords && record.wrongWords.length > 0 && (
                          <div>
                            <div className="font-semibold text-red-700 mb-2">錯誤題目：</div>
                            <div className="space-y-2">
                              {record.wrongWords.map((w, idx) => (
                                <div key={idx} className="p-3 bg-red-50 rounded-lg border border-red-200">
                                  <div className="font-semibold text-gray-800">{w.word}</div>
                                  {w.question && (
                                    <div className="text-sm text-gray-600 mt-1">題目：{w.question}</div>
                                  )}
                                  {w.correctAnswer && (
                                    <div className="text-sm mt-1">
                                      <span className="text-gray-500">正確答案：</span>
                                      <span className="text-green-600 font-semibold ml-1">{w.correctAnswer}</span>
                                    </div>
                                  )}
                                  {w.userAnswer && (
                                    <div className="text-sm mt-1">
                                      <span className="text-gray-500">你的答案：</span>
                                      <span className="text-red-600 font-semibold ml-1">{w.userAnswer}</span>
                                    </div>
                                  )}
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                        
                        {record.learningWords && record.learningWords.length > 0 && (
                          <div>
                            <div className="font-semibold text-orange-700 mb-2">學習中單字：</div>
                            <div className="space-y-2">
                              {record.learningWords.map((w, idx) => (
                                <div key={idx} className="p-3 bg-orange-50 rounded-lg border border-orange-200">
                                  <div className="font-semibold text-gray-800">{w.word}</div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        );
      };

      const SelfTests = ({ data }) => {
        const [open, setOpen] = useState(false);
        const results = useMemo(() => {
          const r = [];
          const rows1 = parseCSV('英文,中譯\n"a,b",好\n'); r.push({name:'CSV quoted comma (LF)', pass: rows1.length===1 && (rows1[0].英文==='a,b' || rows1[0]['a,b']==='好')});
          const rows2 = parseCSV('英文,中譯\r\n"a,b",好\r\n'); r.push({name:'CSV quoted comma (CRLF)', pass: rows2.length===1});
          const after = data.find((w)=>w.english_word.toLowerCase()==='after'); r.push({name:'Multi-POS seed union', pass: !!(after && after.posTags.includes('preposition') && after.posTags.includes('conjunction'))});
          const c1 = makeCloze('They add values.', 'add'); r.push({name:'Cloze basic', pass: /_____/.test(c1)});
          const c2 = makeCloze('C++ is powerful.', 'C++'); r.push({name:'Cloze escapes symbols', pass: /_____/.test(c2)});
          r.push({name:'POS normalize pronoun', pass: normalizePOS('代名詞')==='pronoun'});
          r.push({name:'POS normalize adv.', pass: normalizePOS('adv.')==='adverb'});
          const ms = multiSplit('a，b\nc'); r.push({name:'multiSplit Chinese & LF', pass: ms.length===3 && ms[0]==='a' && ms[1]==='b' && ms[2]==='c'});
          const g1 = grammarDefaults('we','pronoun','主格代名詞'); r.push({name:'Grammar default pronoun subj.', pass: /主詞/.test(g1.grammar_function) && /we/.test(g1.sentence_pattern)});
          const g2 = grammarDefaults('always','adverb',''); r.push({name:'Grammar default adverb frequency', pass: /頻率/.test(g2.grammar_function)});
          const t1 = translationFor('activity','noun'); r.push({name:'translation default noun', pass: /^這是/.test(t1)});
          const t2 = translationFor('add','verb'); r.push({name:'translation default verb', pass: /(每天add。|每天加。)$/.test(t2)});
          return r;
        }, [data]);
        const passCount = results.filter(x=>x.pass).length;
        return (
          <div className="mt-6">
            <button className="text-xs text-indigo-600 underline" onClick={()=>setOpen(o=>!o)}>{open?"隱藏開發測試":"顯示開發測試"}（{passCount}/{results.length} 通過）</button>
            {open && (<ul className="text-xs text-gray-600 list-disc pl-5 mt-2">{results.map((t,i)=>(<li key={i}>{t.name}: {t.pass?"PASS":"FAIL"}</li>))}</ul>)}
          </div>
        );
      };

      function App(){
        const { hash, push } = useHashRoute();
        const favoritesApi = useFavorites();
        const userExamplesApi = useUserExamples();
        const { data, addItems, reset } = useDataset();
        
        // 自動為 conservation 補上影片連結（測試用）
        useEffect(() => {
          const conservation = data.find(w => w.english_word === 'conservation');
          if (conservation && !conservation.videoUrl) {
            conservation.videoUrl = 'https://www.youtube.com/watch?v=C8iYen-4V2A';
            console.log('已自動為 conservation 補上影片連結');
          }
        }, [data]);
        
        const [route, param] = useMemo(() => {
          const h=hash.replace(/^#\//, "");
          if(!h) return ["home", null];
          const [p0,p1]=h.split("?")[0].split("/");
          if(p0==="") return ["home", null];
          if(p0==="category") return ["category", p1];
          if(p0==="word") return ["word", p1];
          if(p0==="favorites") return ["favorites", null];
          if(p0==="quiz-history") return ["quiz-history", null];
          if(p0==="quiz") return ["quiz", null];
          return ["home", null];
        }, [hash]);
        const [navHistory, setNavHistory] = useState(() => ({ current: { route, param }, previous: null }));
        useEffect(() => {
          setNavHistory(prev => {
            if (prev.current.route === route && prev.current.param === param) return prev;
            return { current: { route, param }, previous: prev.current };
          });
        }, [route, param]);
        const quizHistoryApi = useQuizHistory();
        
        return (
          <Shell onReset={reset}>
            {route === "home" && <><Home push={push} data={data} onImport={addItems} /><SelfTests data={data} /></>}
            {route === "category" && <CategoryList cat={param} data={data} />}
            {route === "word" && <WordDetail id={param} data={data} favoritesApi={favoritesApi} userExamplesApi={userExamplesApi} push={push} prevRoute={navHistory.previous} />}
            {route === "favorites" && <FavoritesPage favoritesApi={favoritesApi} data={data} />}
            {route === "quiz-history" && <QuizHistoryPage quizHistoryApi={quizHistoryApi} push={push} data={data} />}
            {route === "quiz" && <QuizPage favoritesApi={favoritesApi} hash={hash} data={data} push={push} />}
          </Shell>
        );
      }

      const rootEl = document.getElementById('root');
      if (rootEl) {
        ReactDOM.createRoot(rootEl).render(<App />);
      }
    </script>
  </body>
</html>
